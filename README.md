# Braid Technologies Studio
- [General Information](#general-information)
- [Technologies](#technologies)
- [Key Components](#key-components)
- [Practices](#practices)
- [License](#license)

## General Information

This repo contains Braid's pattern applications, for use by Braid's clients. Click [here](https://notebooklm.google.com/notebook/1c1a155f-8c18-4e66-abd3-9c73b85f024c/audio?pli=1) for an audio overview generated by NotebookLM.

The first pattern is '**Waterfall**'. Waterfall is a text analyser / classifier, built to illustrate a possible ticket-classification system for Braid's clients. It illustrates the following:

- **Cascade** (a small waterfall) - an Edge plug in, that scrapes the current web page text, summarises it, and then classifies the text into one of Business, Technology, Sport, Health, or Politics. This is the 'Cascade' directory. Cascade is written in typescript/javascript. 

- **Waterfall** - a data analysis back end pipeline. This illustrates a data pipline to download web pages, summarise them, and then use cluster analysis to find the most common topics. This is the 'Waterfall' directory. Waterfall is written in Python. 

'**Api**' contains Azure functions that make calls to an Azure hosted OpenAI model to summrise and classify text. Waterfall, Cascade, and Boxer all call Braid Apis for any function requiring server side keys (database or AI model access).

'**ApiTest**' - code generated by Salon to test the Apis from Python classes.

'**CommonTs**' contains typescript utility classes used across both clients & server - especially API definitions and Types used to generate test scripts. Both subsystems are written in Typescript. Both Cascade and Waterfall make calls to the Apis.

'**CommonPy**' contains Python utility classes used to access the typescript server Apis and to hold common code used in multiple apps.

'**Salon**' - (a place where you do Braiding) is a set of scripts to help the engineering process. One script uses the OpenAI Assistant API to generate test code. It processes API definitions written in JSON and generates Python code to test them. The resulting code is in the 'ApiTest' directory. The second script, repo_to_text, scans a directory system and produces a set of text files containing concatenated code. These files can be loaded into almost any LLM, to use for a 'Chat to your code' assistant. 

'**Boxer**', an AI-enabled learning assistant to help developers build generative AI applications more quickly.  It is a full web front end that passes questions to an LLM, and then enriches them with links to relevant document chunks found in its database of useful material - the A16Z AI Cannon. 

'**Teams**' contains a Teams plug-in that brings Boxer & Waterfall into the teams environment.

'**BoxerEval**' - evals for Boxer. 

## **Technologies**

For front end development Braid uses Typescript (https://www.typescriptlang.org/), using the Microsoft Fluent UI framework (https://react.fluentui.dev/). Tests are written in Mocha (https://mochajs.org/).

For data processing and AI evaluation, Braid uses Python (https://www.python.org/). Tests are written in Pytest (https://docs.pytest.org/en/stable/).

Braid uses Azure for all processing. 

## **Key Components**

1. Document Processing Pipeline:
    - Web scraping (using Beautiful Soup)
    - Text summarization
    - Embedding generation
    - Cluster analysis

2. API Layer:
    - Summarization endpoints
    - Classification services
    - Embedding generation
    - RESTful architecture

3. Testing Framework:
    - Mocha for TypeScript/JavaScript
    - pytest for Python components
    - Automated test generation through Salon

## **Practices**
   
1. Code Organization
    - Core online functionality in TypeScript
    - Use Python for data processing 
    - Maintain clear separation between UI and core logic

2. Testing
    - Write tests for all new features
    - Maintain test coverage above 90%
    - Use appropriate testing frameworks (Mocha for TypeScript, pytest for Python)

3. Documentation
    - Document all public APIs
    - Keep README files updated
    - Include code comments for complex logic

4. Version Control
    - Follow Git branching strategy
    - Write meaningful commit messages
    - Keep PRs focused and manageable


## Branching Strategy

### Branch Types

Based on the Git Flow branching strategy, we have two types of branches:

1. **Long Lived Permanent Branches**
    - `main`
    - `develop`

2. **Secondary Intermediate Supporting Branches**
    - `hotfix`
    - `release`
    - `feature`

### Workflow for Adding a New Feature

On a typical day, a developer (let's call them Developer A) wants to work on a new feature. Here are the steps they follow:

1. **Pull the latest `develop` Branch**
    - Ensure your local `develop` branch is up to date by pulling the latest changes.
    
    ```bash
    git checkout develop
    git pull origin develop
    ```

2. **Create a new feature branch**
    - Create a new branch for your feature. Name the branch descriptively (e.g., `feature/user-login`).

    ```bash
    git checkout -b feature/user-login
    ```

3. **Work locally on the feature branch**
    - Make your changes and commit them to the feature branch.
    
    ```bash
    git add .
    git commit -m "Add user login feature"
    ```

4. **Create a Pull Request (PR)**
    - Once you have a valuable code, push your feature branch to the remote repository and create a PR against the `develop` branch.

    ```bash
    git push origin feature/user-login
    ```

5. **Merge the feature branch**
    - After the PR is approved, an admin will merge the feature branch into the `develop` branch.

### Release Day Workflow

On a release day, the team wants to release a bunch of features to production. Here are the steps they follow:

1. **Create a Release Branch**
    - Create a release branch from the `develop` branch. Name the branch descriptively (e.g., `release/v1.2`).

    ```bash
    git checkout develop
    git pull origin develop
    git checkout -b release/v1.2
    ```

2. **Test and Fix Bugs**
    - Test the `release/v1.2` branch and fix any bugs on this branch. Commit your changes as necessary.

    ```bash
    git add .
    git commit -m "Fix bugs in release v1.2"
    ```

3. **Create a Pull Request (PR) to Main**
    - Create a PR from the `release/v1.2` branch to the `main` branch.

4. **Create a Pull Request (PR) Back to Develop**
    - Create a PR from the `release/v1.2` branch back to the `develop` branch to include any release bug fixes.

#### Admin Tasks

5. **Merge Release Branch**
    - After the PRs are approved, the admin merges the `release/v1.2` branch into both the `main` and `develop` branches.

    ```bash
    git checkout main
    git merge release/v1.2
    git checkout develop
    git merge release/v1.2
    ```

6. **Create a Release Tag**
    - Create a release tag on the `main` branch for the version being released (e.g., `v1.2`).

    ```bash
    git tag v1.2
    git push origin v1.2
    ```

### Problematic Day Workflow

When the team discovers there's an issue in production, here are the steps they follow:

1. **Pull the latest `main` Branch**
    - Ensure your local `main` branch is up to date by pulling the latest changes.
    
    ```bash
    git checkout main
    git pull origin main
    ```

2. **Create a new hotfix branch**
    - Create a new branch for the hotfix. Name the branch descriptively (e.g., `hotfix/system-down`).

    ```bash
    git checkout -b hotfix/system-down
    ```

3. **Work locally on the hotfix branch**
    - Make your changes and commit them to the hotfix branch.
    
    ```bash
    git add .
    git commit -m "Fix system down issue"
    ```

4. **Create a Pull Request (PR) to Main**
    - Create a PR from the `hotfix/system-down` branch to the `main` branch.

4. **Create a Pull Request (PR) to Develop**
    - Create a PR from the `hotfix/system-down` branch to the `develop` branch to cover the issue in future releases.

#### Admin Tasks

5. **Merge the Hotfix Branch**
    - After the PRs are approved, the admin merges the `hotfix/system-down` branch into both the `main` and `develop` branches.

    ```bash
    git checkout main
    git merge hotfix/system-down
    git checkout develop
    git merge hotfix/system-down
    ```

6. **Create a New Tag**
    - Create a new tag for the fix on the `main` branch (e.g., `v1.2.1`).

    ```bash
    git tag v1.2.1
    git push origin v1.2.1
    ```

### Rules of Thumb

1. **Never push directly to `develop` or `main`** 
    - Always create a pull request (PR) for changes.

2. **`main` should always be deployable and working**
    - Ensure that `main` is stable and ready for production at all times.

3. **New work should always be created under feature branches**
    - Develop new features in separate branches for better organization and management.

4. **Create a PR as soon as you get valuable code results**
    - Don't wait until you're done. Create PRs early to create visibility and start the feedback cycle as soon as possible.


## **Licence**
GNU AFFERO GENERAL PUBLIC LICENSE.

This is intentionally a restrictive licence. The source is  available for non-commercial use (subject to the licence terms as listed, which enable use for learning, self study etc). Commercial use either must abide by the licence terms, which are strong, or a separate licence that enables more normal commercial use & distribution is available from Braid. Contact us for more details mailto:info@braidtech.io.
