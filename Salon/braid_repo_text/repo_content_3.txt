****************************************
WaterfallBrowser\src\App.tsx
****************************************
import React from 'react';
import { createRoot } from "react-dom/client";
import { FluentProvider, teamsDarkTheme, makeStyles } from '@fluentui/react-components';
import ChunkRetriever from './ChunkRetriever';
import { retrieveChunk } from './ChunkRetriever';
import reportWebVitals from './reportWebVitals';

const fluidFillPageStyles = makeStyles({
   root: {
      minWidth: "512px",  // Ask for enough for at least the error message  
      height: '100%',  /* fill the screen with flex layout */
      width: '100vw'   /* fill the screen with flex layout */      
   },
});

const pageOuterStyles = makeStyles({
   root: {
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'stretch',    /* for a row, the main axis is vertical, flex-end is items aligned to the bottom of the row */
      justifyContent: 'center', /* for a row, the cross-axis is horizontal, center means vertically centered */
      height: '100%',  /* fill the screen with flex layout */
      width: '100vw',  /* fill the screen with flex layout */
      marginLeft: '0px',
      marginRight: '0px',
      marginTop: '0px',
      marginBottom: '0px',
      paddingLeft: '20px',
      paddingRight: '20px',
      paddingTop: '20px',
      paddingBottom: '20px',
      webkitTextSizeAdjust: '100%'
   },
});

export const innerColumnStyles = makeStyles({
   root: {
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'flex-start',    // start layout at the top       
      alignItems: 'left',
      maxWidth: '896px',
      width: '100vw',  /* fill the screen with flex layout */      
   },
});

function App() {

   const fluidFillPageClasses = fluidFillPageStyles();
   const pageOuterClasses = pageOuterStyles();
   const innerColumnClasses = innerColumnStyles();

   let chunkId : string | undefined = undefined;

   const params = new URLSearchParams(window.location.search);
   let chunkParam = params.get("id");
   console.log(chunkParam); 

   if (chunkParam) {
      chunkId = chunkParam; 
   }
   console.log (chunkId);
   return (
      <FluentProvider theme={teamsDarkTheme} className={fluidFillPageClasses.root}>
         <div className={pageOuterClasses.root}>
            <div className={innerColumnClasses.root}>
               <ChunkRetriever chunkId={chunkId} retrieverFn={retrieveChunk} />
            </div>
         </div>
      </FluentProvider>
   );
}

export default App;

// This allows code to be loaded in node.js for tests, even if we dont run actual React methods
if (document !== undefined && document.getElementById !== undefined) {
   const root = createRoot(document.getElementById("reactRoot") as HTMLElement);
   root.render(
      <React.StrictMode>
         <App />
      </React.StrictMode>      
   ); 
}


// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
****************************************

****************************************
WaterfallBrowser\src\ChunkRetriever.tsx
****************************************
import React, { useState } from 'react';
import { IStoredChunk } from './CommonTs/src/ChunkRepositoryApi.Types';
import { ChunkRepostoryApi } from './CommonTs/src/ChunkRepositoryApi';
import { getDefaultEnvironment } from './CommonTs/src/IEnvironmentFactory';
import { ChunkView } from './ChunkView';
import { ChunkViewError } from './ChunkViewError';
import { ChunkViewLoading } from './ChunkViewLoading';
import { getDefusc } from './Defusc';

/**
 * Type for a function that returns an IStoredChunk given a key. 
 * This allows test code to replace it with a stub.
 * Production calls the relevant API. 
 **/
export type ChunkRetriveFunction = (chunkId: string | undefined) => Promise <IStoredChunk | undefined>;

/**
 * A React component that retrieves and displays a chunk of data using a provided retrieval function.
 * 
 * @param props - The properties for the component.
 * @param props.chunkId - The unique identifier for the chunk to be retrieved.
 * @param props.retrieverFn - A function that retrieves the chunk data based on the chunkId.
 * 
 * @returns A JSX element displaying the retrieved chunk using the ChunkView component, 
 * or an empty div if the chunk is not yet retrieved.
 * 
 * The component manages the retrieval state using internal state variables to track if the retrieval
 * process is ongoing or completed, and updates the UI accordingly.
 */
export function ChunkRetriever (props: {chunkId: string | undefined, retrieverFn: ChunkRetriveFunction}) {
    
    const [chunk, setChunk] = useState<IStoredChunk | undefined> (undefined);
    const [calling, setCalling] = useState<boolean> (false);    
    const [called, setCalled] = useState<boolean> (false);  

    if (!chunk && props.chunkId) {
       if (!calling && !called) {

       setCalling (true);
        props.retrieverFn (props.chunkId).then ((prom) => {
            setCalling (false);
            setCalled (true);

            let retrivedChunk = prom;
            if (retrivedChunk)
               setChunk (retrivedChunk);
        }).catch ((e) => {
            setCalling (false);
            setCalled (true);

        })
      }
    }
    
    return (
      chunk ? <ChunkView chunk={chunk as unknown as IStoredChunk}/> 
            : calling ? <ChunkViewLoading/> 
                      : <ChunkViewError/>
    );
}

export default ChunkRetriever;

/**
 * Asynchronously retrieves a stored chunk by its unique identifier.
 *
 * @param chunkId - The unique identifier of the chunk to be retrieved.
 * @returns A promise that resolves to the retrieved IStoredChunk or undefined if not found.
 *
 * The function decodes an obfuscated string to obtain an API key, initializes
 * the ChunkRepositoryApi with the default environment and the decoded key,
 * and attempts to load the chunk using the provided chunkId.
 */
export async function retrieveChunk(chunkId: string | undefined): Promise<IStoredChunk | undefined> {

   let defusc = getDefusc();

   let env = getDefaultEnvironment();
   let api = new ChunkRepostoryApi(env, defusc);

   if (chunkId) {
      let loaded = await api.load(chunkId);
      let loadedChunk: IStoredChunk | undefined = loaded as IStoredChunk | undefined;

      return loadedChunk;
   }
   else
      return undefined;
}
****************************************

****************************************
WaterfallBrowser\src\ChunkView.tsx
****************************************
import React, { ReactNode } from 'react';
import { IStoredChunk } from './CommonTs/src/ChunkRepositoryApi.Types';
import { uiAppName, uiBackToParentChunk, uiRelatedChunks } from './UIString';


/**
 * Constructs a URL string by appending the given value as a query parameter.
 *
 * @param value - The string value to be appended as a query parameter.
 * @returns The constructed URL string with the query parameter.
 */
function chunkUrl (value: string) : string {
   return window.location.protocol + '//' + window.location.host + window.location.pathname + '?id=' + value.toString();
}


/**
 * Generates a ReactNode that provides a link back to a parent element.
 *
 * @param value - The identifier for the parent element, used to construct the URL.
 * @returns A paragraph element containing a link if the value is provided, or an empty paragraph if undefined.
 */
function backToParent (value: string | undefined) : ReactNode {

   if (value) {
      let relatedUrl = chunkUrl(value);
      return (<p>{uiBackToParentChunk} <a href={relatedUrl}>{value}</a> </p>)
   }
   else
      return <p></p>
}

/**
 * Maps a string value to a ReactNode containing a paragraph with a hyperlink.
 *
 * @param value - The string value used to generate the URL and key for the ReactNode.
 * @param index - The index of the current element in the array (unused).
 * @param all - The array of strings being processed (unused).
 * @returns A ReactNode containing a paragraph with a hyperlink pointing to a URL
 *          constructed from the input string value.
 */
function mapRelated (value: string, index: number, all: Array<string>) : ReactNode {

   let relatedUrl = chunkUrl(value);
   let nodeWithKey : ReactNode = <p key={value}> <a href={relatedUrl}>{value}</a> </p>;

   return (nodeWithKey)
}

/**
 * Splits the input text into an array of strings based on double newline characters.
 * If no double newline is found, splits by single newline characters.
 * Filters out any empty or whitespace-only strings from the result.
 *
 * @param text - The input string to be split.
 * @returns An array of non-empty strings obtained by splitting the input text.
 */
function splitByNewlines(text: string): string[] {
   if (!text.includes('\n\n')) {
      return text.split('\n\n').filter(str => str.trim().length > 0);
   }
   return text.split('\n').filter(str => str.trim().length > 0);
}

/**
 * Renders a view for a stored chunk, displaying its title, summary, and URL.
 * Includes navigation to the parent chunk and lists related chunks if available.
 * 
 * @param props - Contains the stored chunk data to be displayed.
 * @returns A ReactNode representing the chunk view.
 */
export function ChunkView(props: {chunk: IStoredChunk}) {

    let splitSummary: Array<string> = new Array<string> ();
    let url : string | undefined = undefined

    if (props.chunk.storedSummary?.text) {
        splitSummary = splitByNewlines (props.chunk.storedSummary?.text);
    }


   url = props.chunk.url;

    return (
        <div>
            <p><b>{uiAppName}</b></p>
            &nbsp;                   
            <p><b>{props.chunk.storedTitle?.text}</b></p>
            &nbsp;
            {splitSummary.map((paragraph, index) => (
                <p key={index}>{paragraph}</p>
            ))}
            &nbsp;
            <p>{url ? <a href={url}>{url}</a> : <div/>}</p>
            &nbsp;
            {backToParent (props.chunk.parentChunkId)}
            &nbsp;
            {props.chunk.relatedChunks ? <p>{uiRelatedChunks}</p> : <div/>}            
            {props.chunk.relatedChunks ? props.chunk.relatedChunks.map (mapRelated) : <div/>}
            &nbsp;
        </div>
    );
}

export default ChunkView;
****************************************

****************************************
WaterfallBrowser\src\ChunkViewError.tsx
****************************************
import React from 'react';

import { uiAppName, uiSorryNoData } from './UIString';

export function ChunkViewError () {

    
    return (
        <div>
            <p><b>{uiAppName}</b></p>
            &nbsp;                   
            <p>{uiSorryNoData}</p>
            &nbsp;
        </div>
    );
}

export default ChunkViewError;
****************************************

****************************************
WaterfallBrowser\src\ChunkViewLoading.tsx
****************************************
import React from 'react';

import { uiAppName, uiLoading } from './UIString';

export function ChunkViewLoading () {

    
    return (
        <div>
            <p><b>{uiAppName}</b></p>
            &nbsp;                   
            <p>{uiLoading}</p>
            &nbsp;
        </div>
    );
}

export default ChunkViewLoading;
****************************************

****************************************
WaterfallBrowser\src\Defusc.tsx
****************************************
/**
 * Decodes an obfuscated string using base64 decoding
 * @returns {string} The decoded string value
 */
export function getDefusc (): string {
   let obfusc = "NDliNjUxOTQtMjZlMS00MDQxLWFiMTEtNDA3ODIyOWY0Nzhh"
   let defusc = atob(obfusc);

   return defusc;
}
****************************************

****************************************
WaterfallBrowser\src\ReadMe.Salon.md
****************************************
**App.tsx**

This ReactJS code sets up the structure and styling for a web application. 

It imports necessary libraries, including React components, Fluent UI for styling, and custom components like `ChunkRetriever` and `retrieveChunk` for data fetching. 

`makeStyles` is used to create three custom styles: `fluidFillPageStyles`, `pageOuterStyles`, and `innerColumnStyles`. These styles define the layout properties needed to ensure the application's interface is responsive and properly aligned.

The `App` function initializes and renders the main application. It uses URL search parameters to retrieve a `chunkId` and passes it to the `ChunkRetriever` component.

The module also ensures the application is mounted to the HTML element with id `reactRoot`, and a function called `reportWebVitals` is included for performance monitoring.

Important functions and classes:
- `App`
- `fluidFillPageStyles`
- `pageOuterStyles`
- `innerColumnStyles`
- `ChunkRetriever`
- `retrieveChunk`
- `reportWebVitals`

**ChunkRetriever.tsx**

The code defines a React component `ChunkRetriever` which fetches and displays a chunk of data. It uses internal state variables to manage the retrieval process and show different components (`ChunkView`, `ChunkViewError`, or `ChunkViewLoading`) based on the state.

The component expects properties `chunkId` and `retrieverFn`, which is a function to retrieve chunk data. If the data is being fetched, `ChunkViewLoading` is displayed, once fetched successfully, `ChunkView` is displayed, otherwise `ChunkViewError` is shown.

The `retrieveChunk` function is an asynchronous function that retrieves a chunk by its identifier using `ChunkRepositoryApi`, utilizing configurations from `IEnvironmentFactory` and an obfuscated string for the API key. 

Important classes or functions:
1. `ChunkRetriever()` - Component to fetch and display the chunk.
2. `retrieveChunk()` - Function to asynchronously fetch the chunk data.
3. `ChunkView` - Component to display the chunk.
4. `ChunkViewError` - Component to display errors.
5. `ChunkViewLoading` - Component to display the loading state.

**ChunkView.tsx**

The module defines several functions and a React component for handling and displaying chunks of data.

**Classes/Functions:**
1. **chunkUrl**: Constructs a URL string with a query parameter, using the provided string value.
2. **backToParent**: Generates a ReactNode containing a link back to a parent chunk based on a provided identifier.
3. **mapRelated**: Creates a ReactNode for a list of related chunks, converting each string value into a hyperlink.
4. **splitByNewlines**: Splits a given string into an array based on double or single newline characters, filtering out empty lines.
5. **ChunkView**: A React component that displays chunk data, including title, summary, and URL. It also includes navigation to parent and related chunks if available.

**ChunkViewError.tsx**

This code defines a React functional component named `ChunkViewError`.

The component imports the `uiAppName` and `uiSorryNoData` strings from the `UIString` module.

In the `ChunkViewError` component, it returns a `div` element that contains two paragraphs. The first paragraph displays the `uiAppName` string in bold, and the second paragraph displays the `uiSorryNoData` string.

The `ChunkViewError` component is exported as the default export of the module.

**ChunkViewLoading.tsx**

This code is a React functional component named `ChunkViewLoading`. 

The component imports `uiAppName` and `uiLoading` from a module named `UIString`.

Within the `ChunkViewLoading` component, a div containing two paragraphs is returned. The first paragraph displays `uiAppName` in bold, and the second paragraph displays the `uiLoading` text.

The component is exported as the default export of the module, making it reusable in other parts of the application.

Important Classes/Functions:
- `ChunkViewLoading`: The functional component rendering the UI elements.
- `uiAppName` and `uiLoading`: Imported values used within the component for textual content.

**Defusc.tsx**

The `getDefusc` function is designed to decode an obfuscated string using Base64 decoding.

Inside the function, a variable `obfusc` is assigned a Base64 encoded string: `"NDliNjUxOTQtMjZlMS00MDQxLWFiMTEtNDA3ODIyOWY0Nzhh"`.

The `atob` function is then used to decode this Base64 encoded string and stores the result in the `defusc` variable.

Finally, the function returns the decoded string stored in `defusc`. 

Important function:
- `getDefusc()`: Decodes a predefined Base64 encoded string and returns the decoded value.

**reportWebVitals.ts**

The `reportWebVitals` function aims to report web vital metrics if a valid `onPerfEntry` function is provided. 

The function first checks if `onPerfEntry` exists and is a function. If so, it dynamically imports the 'web-vitals' library.

Upon successful import, the function extracts five methods: `getCLS`, `getFID`, `getFCP`, `getLCP`, and `getTTFB`.

Each of these methods is then called with `onPerfEntry` as an argument, enabling the reporting of the respective web vitals metrics.

The module is structured to be used with any valid `ReportHandler` provided by the 'web-vitals' library.

Key functions include `reportWebVitals` and methods `getCLS`, `getFID`, `getFCP`, `getLCP`, and `getTTFB` from the 'web-vitals' library.

**UIString.ts**

The module `UIString.ts` is part of the Waterfall Browser application and contains user interface text constants.

`uiAppName` is a constant representing the application's name, "Waterfall Browser".

`uiSorryNoData` is a message displayed when data cannot be found using a given ID, "Sorry, we can't fund a chunk of data with that ID."

`uiBackToParentChunk` holds text for navigating back to a parent chunk, "Back to parent:".

`uiRelatedChunks` contains text for displaying related chunks, "Related:".

`uiLoading` represents a loading message, "Loading."
****************************************

****************************************
WaterfallBrowser\src\reportWebVitals.ts
****************************************
/**
 * @module WaterfallBrowser/src/reportWebVitals.ts
 * 
 * This module provides a function to report web vitals metrics.
 */

import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
****************************************

****************************************
WaterfallBrowser\src\UIString.ts
****************************************
/**
 * @module WaterfallBrowser/src/UIString.ts
 * 
 * This module contains UI text constants for the Waterfall Browser application.
 */

export let uiAppName = "Waterfall Browser";
export let uiSorryNoData = "Sorry, we can't fund a chunk of data with that ID.";
export let uiBackToParentChunk = "Back to parent:";
export let uiRelatedChunks = "Related:";
export let uiLoading = "Loading."
****************************************

****************************************
WaterfallBrowser\test\chunkretriever.test.tsx
****************************************
'use strict';
// Copyright Braid technologies ltd, 2024

import { describe, it } from 'mocha';
import { expect } from "expect";
import React from "react";
import { render, screen } from "@testing-library/react";

import { ChunkRetriever } from '../src/ChunkRetriever';
import { testChunkRetriever, parentKey } from './ChunkTestHelpers';

function waitFor(seconds: number): Promise<void> {
   return new Promise(resolve => setTimeout(resolve, seconds * 1000));
}

// https://medium.com/@ufukbakan/testing-react-with-mocha-and-typescript-ultimate-guide-54332de7cf36#:~:text=Open%20package.json%20with%20any%20text%20editor%2C%20find%20the,can%20use%20this%20glob%20matcher%3A%20.%2F%2A%2A%2F%2A.test.%20%5Bjt%5Ds%3F%20%28x%29

describe("ChunkRetriever", function () {

   it("Renders sample Chunk", async function () {

      async function renderfn () { render(<ChunkRetriever chunkId={parentKey} retrieverFn={testChunkRetriever} />); }

      await renderfn();

      await waitFor(19);

      const summaryLinkElement = screen.getByText(/Summary/i);
      expect(summaryLinkElement !== null).toEqual(true);
    
      const titleLinkElement = screen.getByText(/Title/i);
      expect(titleLinkElement !== null).toEqual(true);  
    
      const linkElement = screen.getByText(/microsoft/i);
      expect(linkElement !== null).toEqual(true);  
   }).timeout(20000);
  
}).timeout(20000);
****************************************

****************************************
WaterfallBrowser\test\ChunkTestHelpers.tsx
****************************************

import { IStoredChunk } from '../../CommonTs/src/ChunkRepositoryApi.Types';



export let parentKey = "123";
let childKey1 = "456";
let childKey2 = "789";
let modelKey = "TestModel";

let now = new Date().toUTCString();

export let testChunk: IStoredChunk = {
   id: parentKey,
   applicationId: "Test",
   schemaVersion: "1",
   created: now,
   amended: now,
   contextId: "madeupId",
   userId: "madeupId",
   className: "madeUpClass",
   functionalSearchKey: parentKey,
   parentChunkId: undefined,
   originalText: undefined,
   url: "https://microsoft.com",
   storedEmbedding: undefined,
   storedSummary: {modelId: modelKey, text: "Summary Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."},
   storedTitle: {modelId: modelKey, text: "Title"},
   relatedChunks: [childKey1, childKey2]
}

export let childChunk1: IStoredChunk = {
   id: childKey1,
   applicationId: "Test",
   schemaVersion: "1",
   created: now,
   amended: now,
   contextId: "madeupId",
   userId: "madeupId",
   className: "madeUpClass",
   functionalSearchKey: childKey1,
   parentChunkId: parentKey,
   originalText: undefined,
   url: "https://microsoft.com",
   storedEmbedding: undefined,
   storedSummary: {modelId: modelKey, text: "Summary Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."},
   storedTitle: {modelId: modelKey, text: "Title"},
   relatedChunks: undefined
}

export let childChunk2: IStoredChunk = {
   id: childKey1,
   applicationId: "Test",
   schemaVersion: "1",
   created: now,
   amended: now,
   contextId: "madeupId",
   userId: "madeupId",
   className: "madeUpClass",
   functionalSearchKey: childKey2,
   parentChunkId: parentKey,
   originalText: undefined,
   url: "https://microsoft.com",
   storedEmbedding: undefined,
   storedSummary: {modelId: modelKey, text: "Summary Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."},
   storedTitle: {modelId: modelKey, text: "Title"},
   relatedChunks: undefined
}

export let parentChunk = testChunk;


export async function testChunkRetriever (chunkId: string | undefined) : Promise <IStoredChunk | undefined> {

   switch (chunkId) {
      case parentKey:
         return parentChunk;
      case childKey1:
         return childChunk1;        
      case childKey2:
         return childChunk2;            
      default:
         return undefined;
   }
}
****************************************

****************************************
WaterfallBrowser\test\chunkview.test.tsx
****************************************
'use strict';
// Copyright Braid technologies ltd, 2024

import { describe, it } from 'mocha';
import { expect } from "expect";
import React from "react";
import { render, screen } from "@testing-library/react";

import { ChunkView } from '../src/ChunkView';
import { testChunk } from './ChunkTestHelpers';

// https://medium.com/@ufukbakan/testing-react-with-mocha-and-typescript-ultimate-guide-54332de7cf36#:~:text=Open%20package.json%20with%20any%20text%20editor%2C%20find%20the,can%20use%20this%20glob%20matcher%3A%20.%2F%2A%2A%2F%2A.test.%20%5Bjt%5Ds%3F%20%28x%29

describe("ChunkView", function () {

   it("Renders sample Chunk", function () {

      render(<ChunkView chunk={testChunk}/>);

      const summaryLinkElement = screen.getByText(/Summary/i);
      expect(summaryLinkElement !== null).toEqual(true);
    
      const titleLinkElement = screen.getByText(/Title/i);
      expect(titleLinkElement !== null).toEqual(true);  
    
      const linkElement = screen.getByText(/microsoft/i);
      expect(linkElement !== null).toEqual(true);  
   });
  
});
****************************************

****************************************
WaterfallBrowser\test\ReadMe.Salon.md
****************************************
**chunkretriever.test.tsx**

This script is a test suite for the `ChunkRetriever` React component using the Mocha testing framework and Expect for assertions. 

The `waitFor` function creates a delay specified by the input seconds.

The `describe` block names the test suite "ChunkRetriever" and contains individual tests.

The `it` block defines a test named "Renders sample Chunk", where the `renderfn` function asynchronously renders the `ChunkRetriever` component.

The test waits for 19 seconds to ensure the component loads fully, then checks that elements with the text "Summary," "Title," and "microsoft" exist in the document.

The timeout for these tests is set to 20000 milliseconds (20 seconds).

**ChunkTestHelpers.tsx**

The code defines and initializes three chunk objects implementing the `IStoredChunk` interface: `testChunk`, `childChunk1`, and `childChunk2`, representing a parent chunk and two child chunks, respectively. Each chunk contains metadata such as creation timestamps, context and user IDs, and URLs.

The `testChunkRetriever` function takes a chunk ID and returns the corresponding chunk object if it matches one of the predefined IDs (`parentKey`, `childKey1`, or `childKey2`), otherwise returns `undefined`.

The provided keys (`parentKey`, `childKey1`, `childKey2`, and `modelKey`) and a formatted current timestamp (`now`) are used throughout. 

Classes/Functions:
- `testChunkRetriever()`
- `IStoredChunk`

**chunkview.test.tsx**

This code is a test module for a React component, `ChunkView`, using Mocha and Expect for testing, and React Testing Library for rendering.

The `describe` function from Mocha groups the tests under the "ChunkView" label.

The `it` function defines a test case named "Renders sample Chunk."

The `render` function from React Testing Library renders the `ChunkView` component with a test chunk, `testChunk`.

`screen.getByText` is used to assert that elements with the texts "Summary", "Title", and "microsoft" are present in the rendered output.

Important classes or functions:
- `describe`
- `it`
- `render`
- `screen.getByText`
- `expect`
- `ChunkView`
- `testChunk`
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Model.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import { InvalidParameterError } from './Errors';
import { IModel } from './IModel';
import GPT4Tokenizer from 'gpt4-tokenizer';

const tokenizer = new GPT4Tokenizer({ type: 'gpt3' });


/**
 * GPTM class implementing IModel interface.
 * Represents a model with specific deployment settings and context window sizes.
 */
export class GPT4 implements IModel {

   deploymentName: string;
   embeddingDeploymentName: string;
   contextWindowSize: number;
   contextWindowSizeWithBuffer: number;

   public constructor() {
      this.deploymentName = "GPT4o";
      this.embeddingDeploymentName = "Embed-3";
      this.contextWindowSize = 8192;
      this.contextWindowSizeWithBuffer = (8192 - 256)
   }

   /**
    * Checks if the given text fits within the context window size with buffer.
    * 
    * @param text The text to check if it fits within the context window size with buffer.
    * @returns True if the text fits within the context window size with buffer, false otherwise.
    */
   fitsInContext(text: string): boolean {

      let estimatedTokens = tokenizer.estimateTokenCount(text);

      if (estimatedTokens < this.contextWindowSizeWithBuffer)
         return true;
      return false;
   }

   /**
    * Splits the input text into chunks based on the specified overlap of words.
    * 
    * @param text The text to be chunked.
    * @param overlapWords The number of overlapping words between consecutive chunks. If undefined, we chunk with no obverlap. 
    * @returns An array of strings representing the chunked text.
    */
   chunkText(text: string, chunkSize: number | undefined, overlapWords: number | undefined): Array<string> {

      let effectiveChunkSize = chunkSize
         ? Math.min(this.contextWindowSizeWithBuffer, chunkSize)
         : this.contextWindowSizeWithBuffer;

      if (overlapWords) {

         if (overlapWords > effectiveChunkSize)
            throw new InvalidParameterError ("Overlap window size cannot be bigger than chunk size")

         // If the users requests overlapping chunks, we divide the text into pieces the size of the overlap, then glue them back
         // together until we fill a buffer. 
         let chunked = tokenizer.chunkText(text, Math.floor(overlapWords * 2));
         let chunks = new Array<string>();

         let workingBufferText = "";
         let workingBufferTokens = 0;
         let lastChunkText = "";
         let lastChunkTokens = 0;

         for (let i = 0; i < chunked.length; i++) {

            let thisChunkText = chunked[i].text;
            let thisChunkTokens = tokenizer.estimateTokenCount(thisChunkText);

            if (workingBufferTokens + thisChunkTokens < effectiveChunkSize) {
               // If we are within buffer size, we just accumulate
               workingBufferText = workingBufferText + thisChunkText;
               workingBufferTokens = workingBufferTokens + thisChunkTokens;
            }
            else {
               // If we are outside buffer, we save the current chunk and build the start of the next one
               chunks.push(workingBufferText);

               workingBufferText = lastChunkText + thisChunkText
               workingBufferTokens = lastChunkTokens + thisChunkTokens;
            }

            // If we have reached the last chunk, we have to save it. 
            if (i === chunked.length - 1) {
               chunks.push(workingBufferText);
            }

            lastChunkTokens = thisChunkTokens;
            lastChunkText = thisChunkText;
         }
         return chunks;
      }
      else {
         let chunked = tokenizer.chunkText(text, effectiveChunkSize);

         let chunks = new Array<string>();

         for (let i = 0; i < chunked.length; i++) {
            chunks.push(chunked[i].text);
         }
         return chunks;
      }
   }

   /**
    * Estimates the number of tokens in the provided text using the tokenizer.
    * 
    * @param text The text for which to estimate the number of tokens.
    * @returns The estimated number of tokens in the text.
    */
   estimateTokens(text: string): number {

      return tokenizer.estimateTokenCount(text);
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\PromptPersona.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd


import { EPromptPersona } from "./IPromptPersona";
import { IPromptPersona } from "./IPromptPersona";

export const ArticleSummariserPersona: IPromptPersona = {

   name: EPromptPersona.kArticleSummariser,
   systemPrompt: "",
   itemPrompt: ""
};

export const CodeSummariserPersona: IPromptPersona = {

   name: EPromptPersona.kCodeSummariser,
   systemPrompt: "",
   itemPrompt: ""
};
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SuppressSummariseFailApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the SuppressSummariseFail API

/**
 * Defines the structure of a summarise request object.
 */
export interface ISuppressSummariseFailRequest{

   text: string;
   lengthInWords?: number | undefined;
}

export enum ESuppressSummariseFail {
   kYes = "Yes",
   kNo = "No"
}

/**
 * Defines the structure of a summarise response object.
 */
export interface ISuppressSummariseFailResponse {

   isValidSummary: ESuppressSummariseFail;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SuppressSummariseFailApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from SuppressSummariseFailApi.Types.yaml with typeconv
  version: '1'
  x-id: SuppressSummariseFailApi.Types.yaml
  x-comment: >-
    Generated from src\SuppressSummariseFailApi.Types.ts by
    core-types-json-schema (https://github.com/grantila/core-types-json-schema)
    on behalf of typeconv (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    ISuppressSummariseFailRequest:
      properties:
        text:
          title: ISuppressSummariseFailRequest.text
          type: string
        lengthInWords:
          title: ISuppressSummariseFailRequest.lengthInWords
          type: number
      required:
        - text
      additionalProperties: false
      title: ISuppressSummariseFailRequest
      description: Defines the structure of a summarise request object.
      type: object
    ISuppressSummariseFailResponse:
      properties:
        isValidSummary:
          title: ISuppressSummariseFailResponse.isValidSummary
      required:
        - isValidSummary
      additionalProperties: false
      title: ISuppressSummariseFailResponse
      description: Defines the structure of a summarise response object.
      type: object
****************************************

****************************************
Boxer\core\ReadMe.Salon.md
****************************************
**ActivityRecord.ts**

The `ActivityRecord` module defines interfaces for storing user activity records within the Braid system. The main interfaces include `IStoredActivity`, `IStoredUrlActivity`, `IStoredLikeUrlActivity`, and `IStoredMessageActivity`.

Each interface extends `IStorable` to ensure persistence and includes versioning through the `className` and `schemaNumber` constants. 

`IStoredActivity` serves as a base interface. `IStoredUrlActivity` adds a URL field. `IStoredLikeUrlActivity` includes a boolean `like`. `IStoredMessageActivity` includes a `message` field.

Utility function `makeDateUTC` converts dates to UTC format for consistent storage, truncating milliseconds as recommended by Cosmos DB.

**ActivityRepository.ts**

The `ActivityRepository` module provides an implementation for storing and retrieving user activities in a system called Braid, interfacing with Cosmos DB. 

The `ActivityRepositoryCosmos` class implements the `IActivityRepository` interface and is responsible for saving activity records (such as URLs visited, likes/unlikes, and messages) and loading recent activities. It requires a session key for authentication.

The `save`, `loadRecentUrlActivity`, `loadRecentMessages`, `loadRecent`, and `removeMessageRecord` functions handle specific operations related to activity persistence and retrieval.

The module uses external libraries such as `axios` for HTTP requests and imports several interfaces and classes related to activity records, environment configuration, and API interactions.

**AIConnection.ts**

### Overview
The `AIConnection` module manages communication between the Boxer application and AI/LLM services.

### Classes and Important Functions
**AIConnection Class**
- **constructor(sessionKey_)**: Initializes `AIConnection` with session key and sets up the API connection.
- **makeEnrichedCall(responseShell, query)**: Makes a call to the AI model to get enriched responses, then streams the result to the UI.
- **makeFollowUpCall(summary)**: Asks the AI model for a relevant question based on provided context.
- **streamResponse(responseShell, response)**: Simulates streaming a response back to the UI by updating the message object.
- **isBusy()**: Checks if there are active AI calls.
- **buildEnrichmentQuery(messages, authors)**: Constructs an enriched query from the conversation history to send to the AI model.
- **buildQueryForQuestionPrompt(summary)**: Creates a query to generate follow-up questions.
- **buildTranscript(messages, authors)**: Builds a conversation transcript.
- **findEarliestMessageIndexWithinTokenLimit(messages, authors)**: Finds the earliest message within token limits to include in the query.

**Helper Functions and Checks**
- **isFromLLM(message, authors)**: Checks if a message is from the LLM.
- **isRequestForLLM(message, authors)**: Determines if a message is an LLM request.
- **mightBeMissTypedRequestForLLM(message, authors)**: Checks if a message is a misspelled attempt to request the LLM.

**ApiCalls.ts**

This code module, named `ApiCalls`, is designed for making API requests to the Braid Technologies backend, specifically focusing on summarization via the Summarise API.

The `makeSummaryCall` function is the primary function here. It takes a `SessionKey` and a string of `text` to be summarized. It constructs a summarization request and makes an HTTP POST request to the summarization API using axios. If the request is successful, it returns the summary; otherwise, it logs the error using `logApiError`.

Key imports include `axios` for HTTP requests, `SessionKey` for session management, and several configuration and type definitions from various local and shared modules.

**Asserts.ts**

The module named "Asserts" provides utility functions to verify the validity of objects by checking if they are undefined or null, ensuring type safety and preventing runtime errors.

The function `throwIfUndefined` checks if a given object is undefined and throws an `AssertionFailedError` if it is. 

The function `throwIfNull` checks if a given object is null and throws an `AssertionFailedError` if it is.

The `AssertionFailedError` class, imported from the './Errors' module, is presumably used to represent an error specifically related to failed assertions.

**BoxerFluidConnection.ts**

**BraidFluidConnection Class**
- **Module Purpose**: Manages the Fluid connection for the Boxer application by handling participants and message caucuses, tracking call state, and building enriched queries from message history.
- **Authentication and Configuration**: Requires a session key and uses environment configuration for API endpoints. Interacts with QueryModelApi for API calls.
- **Class Properties**: Manages internal state including participants, messages, shared embeddings, and interval timers.
- **Setup**: Initialize local caucuses for participants, messages, and shared embeddings; adds the local user and a bot persona.
- **Methods**: 
  - `schema`: Returns the container schema.
  - `setupLocalCaucuses`: Establishes local caucuses and sets an interval to ensure the local user is added.
  - `disconnectLocalCaucuses`: Clears the interval.
  - `participantCaucus`, `messageCaucus`, `sharedEmbeddingCaucus`: Retrieve respective caucuses.
  - `resetMessages`: Resets messages and participants.
  - `setInitialValues`: Adds the local user and bot persona to the participant caucus.
  - **Utility Functions**:
    - `checkAddAddSelfToAudience`: Ensures the local user is part of the participant caucus.

**CaucusFramework.ts**

###  Brief Summary of the Code

1. **Module Purpose**: The `CaucusFramework` module manages shared state (caucuses) in the Boxer application using the `CaucusOf` class, which allows adding, removing, and updating elements within a map structure.

2. **Key Class**: The `CaucusOf` class extends the `Notifier` class, providing notification functionalities when elements are added, changed, or removed. It uses static interests (`caucusMemberAddedInterest`, `caucusMemberChangedInterest`, and `caucusMemberRemovedInterest`) for these notifications.

3. **Constructor**: The constructor initializes the class and sets up event handling for shared map value changes and debounced kickstarter for updates.

4. **Primary Methods**: `add`, `remove`, `amend`, `get`, `removeAll`, `current`, `currentAsArray`, `synchFrom`, and `updateCache` manage the lifecycle and synchronization of map entries.

5. **Notifications**: The `doNotification` method dispatches notifications about changes in map entries.

6. **Utility Methods**: Includes utility functions like `has` for checking key existence and `binarySearch` for searching sorted arrays efficiently.

This ensures efficient management of shared data with notification mechanisms for observing changes.

**ConfigStrings.ts**

This module provides constants for the Boxer application configuration, including string and numeric values for various settings. 

The `EConfigStrings` enum contains configuration strings such as logging categories (`kCoreLogCategory`, `kApiLogCategory`, `kDbLogCategory`), URLs (`kHomeRelativeUrl`, `kAzureProductionFluidHost`), AI model identifiers (`kLLMName`, `kLLMGuid`), and conversation keys (`kCohort1ConversationKey`).

The `EConfigNumbers` enum contains numeric constants for the application’s settings, such as delays and limitations (`kInitialHelpfulPromptDelayMsecs`, `kMaximumLinkTextlength`, `kSummaryLengthWords`).

`KStubEnvironmentVariables` is an object for local environment variables, never to include production secrets.

**Debounce.ts**

The `debounce` module provides a utility function to limit the rate at which a function (`fn_`) is called, ensuring it is not invoked more frequently than the specified delay (`ms_`).

The `debounce` function takes two arguments: a function (`fn_`) and a delay time in milliseconds (`ms_`). It returns a new function.

Within the returned function, a timer is started using `setTimeout`. The timer, if active, ensures that the original function only runs after the delay period.

The `throwIfNull` function from the `Asserts` module checks for a null timer.

Key functions:
- `debounce(fn_: Function, ms_: number): Function`

**Errors.ts**

The module "Errors" provides a set of custom error classes tailored for the Boxer application. Each class extends the native `Error` class in JavaScript, allowing for specialized error handling.

The important classes include:
- `InvalidParameterError`
- `InvalidOperationError`
- `InvalidStateError`
- `ConnectionError`
- `EnvironmentError`
- `AssertionFailedError`

Each class overrides the default constructor to ensure the error name is set correctly and logs the error using either `logApiError` or `logCoreError` functions. The `Object.setPrototypeOf` method is used to restore the prototype chain, ensuring stack traces display correctly.

**FluidConnection.ts**

### Overview
The `FluidConnection` module provides a base class designed to manage Fluid connections in the Boxer application, allowing for creating, attaching to, and disconnecting from Fluid containers. It manages participant caucuses and keeps track of the active call state.

### Key Components
- **FluidConnection Class:** The main class providing methods for managing Fluid containers.
- **createNew:** This async method creates a new Fluid container and sets up the connection.
- **attachToExisting:** This async method attaches to an existing Fluid container.
- **disconnect:** This method disconnects from the Fluid container if it is connected.
- **setupBeforeConnection:** A private method to initialize the environment and client before making a connection.
- **setupAfterConnection:** A private method to set up local caucuses after connection.
- **schema:** An abstract method to be implemented for container schema.
- **setupLocalCaucuses and disconnectLocalCaucuses:** Abstract methods to manage local participant caucuses.

### Dependencies
- **Fluid Framework (`fluid-framework`):** For Fluid containers and connection state management.
- **Azure Client (`@fluidframework/azure-client`):** For Fluid client properties and connecting to Azure services.
- **SessionKey and ConversationKey:** For authentication and conversation identification.
- **Error and Logging Modules:** For error handling and logging.

**IActivityRepository.ts**

This code defines an `IActivityRepository` interface in TypeScript.

The `IActivityRepository` interface includes four methods:
1. `save(record: IStoredActivity): Promise<boolean>` - This method is used to save an activity record and returns a Promise that resolves to a boolean indicating success.
2. `loadRecentUrlActivity(count: number): Promise<Array<IStoredActivity>>` - This method loads a specified number of recent URL activities, returning a Promise that resolves to an array of `IStoredActivity` records.
3. `loadRecentMessages(count: number): Promise<Array<IStoredActivity>>` - This method retrieves a set number of recent messages, returning a Promise that resolves to an array of `IStoredActivity` records.
4. `removeMessageRecord(messageId: string): Promise<boolean>` - This method removes a message record based on its ID and returns a Promise that resolves to a boolean indicating success.

The module imports `IStoredActivity` from another file `ActivityRecord`, indicating that this interface relies on activity record definitions from that module.

**IActivityRepositoryFactory.ts**

The `IActivityRepositoryFactory` module provides a factory function for creating activity repositories.

The `getRecordRepository` function, a key function in this module, creates and returns an implementation of `IActivityRepository` based on a provided session key.

Currently, it returns an instance of `ActivityRepositoryCosmos`, which is a Cosmos DB-backed implementation of the activity repository.

The important classes and functions in the module are:
- `getRecordRepository`
- `SessionKey`
- `IActivityRepository`
- `ActivityRepositoryCosmos`

**IAdminRepository.ts**

This module provides an interface for checking if a user is an admin, using `IAdminRepository`.

The `IAdminRepository` interface includes a method `isAdmin` that takes a `Persona` object and returns a `Promise<boolean>` indicating admin status.

The `getDefaultAdminRepository` function returns an instance of `DefaultAdminRepository`, a local implementation of `IAdminRepository`.

`DefaultAdminRepository` implements the `isAdmin` method, which checks if the `persona`'s name is present in `EConfigStrings.kAdminUserNames` to determine if the user is an admin.

Important classes/functions:
- `IAdminRepository`
- `getDefaultAdminRepository`
- `DefaultAdminRepository`

**Icons.ts**

This code module, named "Icons," is a part of the Boxer application developed by Braid Technologies Ltd. It defines an enumeration (enum) called `EIcon`.

`EIcon` contains string values that represent different icon names used within the application. The icons include `kPersonPersona`, `kLLMPersona`, `kBotPersona`, `kUnknownPersona`, and `kFromBcd`.

The `kBotPersona` entry is noted to be present for backward compatibility. 

This module helps in managing and standardizing the use of these icon names across the Boxer application.

**IKeyGenerator.ts**

The `IKeyGenerator` module provides an interface for generating and managing unique keys and secrets. 

**`generateKey`**: Method to generate a unique key.

**`generateSecret`**: Method to generate a secret.

**`couldBeAKey`**: Method to check if a given string could be a valid key.

**`saveSecret`**: Method to save a generated secret.

**`matchesSavedSecret`**: Method to check if a given secret matches the saved secret.

**`haveSavedSecret`**: Method to verify if there is a secret currently saved.

**`savedSecret`**: Method to retrieve the saved secret.

This ensures consistent implementation for any class needing unique key generation and secret management functionality.

**IKeyGeneratorFactory.ts**

The module `IKeyGeneratorFactory` provides a factory function for creating key generators.

The `getDefaultKeyGenerator` function is exported from this module. 

`getDefaultKeyGenerator` returns a new instance of the `UuidKeyGenerator` class, which implements the `IKeyGenerator` interface.

Important classes and functions:
1. `getDefaultKeyGenerator` - the factory function.
2. `IKeyGenerator` - the interface for key generators.
3. `UuidKeyGenerator` - the class providing the implementation for key generation.

**JoinDetails.ts**

The `JoinDetails` class manages join details in the Boxer application.

- It handles parsing join details from a string, validating them, creating join details from parts, and converting them to a string.
- Private variables include `_email`, `_name`, `_session`, `_conversation`, and `_secret`.
- The constructor initializes these variables and parses an input string to assign values.
- Getters provide access to private variables.
- The `toString` method formats the join details as a string.
- The `canAttemptJoin` method checks if the details allow for joining based on environmental conditions.
- `makeFromParts` creates an instance from given parts.
- The `validateEmail` function validates email strings.

**JoinPageValidator.ts**

The `JoinPageValidator` class is designed to validate join details within the Boxer application. It ensures a user can successfully join a conversation and handles the management of saved secrets. This class provides the following methods:

- `canAttemptJoin(email_, name_, session_, conversation_)`: Returns `true` if the provided email, name, session key, and conversation key are valid for attempting to join a conversation, using the `JoinDetails` class.
  
- `matchesSavedSecret(secret_)`: Checks if the provided secret matches the saved secret using a key generator.

- `haveSavedSecret()`: Returns `true` if there is a saved secret available.

- `savedSecret()`: Retrieves the saved secret.

Important modules used include `JoinDetails`, `SessionKey`, `ConversationKey`, and `IKeyGeneratorFactory`.

**KeyRetriever.ts**

The `KeyRetriever` module provides a class dedicated to retrieving keys from the Braid backend system.

The `KeyRetriever` class handles making API calls using Axios to retrieve keys based on provided URLs and parameters. It also tracks the state of active calls and logs any errors that occur during the process. `activeCallCount` is used to track how many requests are currently active.

The `requestKey` method is an asynchronous function that makes a GET request to the specified API URL with provided parameters. If an error occurs during the request, it decreases the active call count and logs the error.

The method `isBusy` checks if there are any active calls by returning a boolean indicating whether `activeCallCount` is non-zero.

Important classes and functions:
- `KeyRetriever`
- `requestKey`
- `isBusy`

**Keys.ts**

This module, named `Keys`, is used within the Boxer application to manage keys. It includes two main classes: `SessionKey` and `ConversationKey`.

The `SessionKey` class wraps a session ID string and provides methods to validate if it looks like a valid UUID using an `IKeyGenerator` instance obtained from `getDefaultKeyGenerator`. It also includes a method to convert the session key to a string representation.

The `ConversationKey` class similarly wraps a conversation ID string, offering methods for validation as a UUID and conversion to string. Both classes facilitate the creation, validation, and string conversion of keys within the application.

**Like.ts**

The `Like` class in this module is designed for the Boxer application to manage like objects. This class supports different constructor patterns to create a `Like` object from name and timestamp, initialized with empty properties, or copied from an existing instance.

Important methods include:
- **`streamOut`**: Converts the `Like` object to a JSON string.
- **`streamIn`**: Rebuilds a `Like` object from a JSON string.
- **`equals`**: Compares two `Like` objects for equality.
- **`assign`**: Assigns properties from another `Like` object.

The class also includes getter and setter methods for the private properties `_name` and `_when`.

**Logging.ts**

This module, `Logging`, provides a logging system for the Boxer application. It is intended to log errors and information to the console.

The module imports logging functionalities from the 'missionlog' library and configuration strings from './ConfigStrings'.

The logger object is defined to handle different logging levels (ERROR, WARN, INFO, TRACE, DEBUG) with appropriate console methods.

Initializes the logging system with the `log.init` function, setting different logging levels to 'DEBUG' and using the logger object to handle logging.

The module exports four main functions: `logCoreError`, `logDbError`, `logApiError`, and `logApiInfo`, which log messages at the ERROR or INFO level to the console, categorized by core, database, and API.

**Media.ts**

The code defines the `Media` class for managing media queries, particularly focusing on mobile form factor boundaries.

The constructor initializes an array for listeners and a `MediaQueryList` to track changes to a specific media query (maximum width of 1023px), adding an event listener for these changes.

The `isSmallFormFactor()` method returns a boolean indicating if the display width is within the mobile form factor boundary.

The `onMobileFormFactorChange()` method handles changes to the mobile form factor by updating internal state and notifying external listeners.

The `addMobileFormFactorChangeListener(fn: Function)` method allows users to add custom functions to be executed when the media query's state changes.

**Message.ts**

The `Message` module provides a class named `Message` for managing messages in the Boxer application.

The `Message` class allows the creation of message objects with properties like text, author, responseTo, timestamp, and chunks of relevant enriched data sources. It supports multiple constructor patterns for object initialization, copying from JSON, or constructed sources.

Key functionalities include:
- Streaming support with handlers for live text and chunk updates.
- Methods for token counting and manipulation.
- Serialization and deserialization mechanisms for the streaming framework.
- Utilities for validating message IDs and checking object equality.

Important classes and functions:
- `Message`
- `MessageStreamingHandler` for handling message streaming.

**NotificationFramework.ts**

The `NotificationFramework` module manages notifications within the Boxer application. 

The `Interest` class encapsulates the concept of what is being observed with a specific `notificationId`. It handles creating, managing, copying, and comparing Interests with multiple initialization constructors.

The `Notification` class is a base class that references the `Interest`. It manages creating, copying, comparing, and assigning notifications.

The `NotificationFor` class extends `Notification` to include an additional data payload.

The `ObserverInterest` class combines an `IObserver` and an `Interest`, tracking what observers are interested in.

The `NotificationRouter` and `NotificationRouterFor` classes implement routing functions to handle notifications, ensuring type safety.

The `Notifier` class sends notifications to observers when things change, managing adding, removing, and notifying observers through `ObserverInterest` instances.

Key classes and functions: `Interest`, `Notification`, `NotificationFor`, `ObserverInterest`, `NotificationRouter`, `NotificationRouterFor`, `Notifier`, `IObserver`, `INotifier`.

**Persona.ts**

The module provides a `Persona` class to manage personas in the Boxer application, tracking names, icons, and timestamps.

`Persona` supports multiple constructor patterns to create objects from scratch, copy from JSON, or other sources. It includes getters and setters for private attributes like `_id`, `_name`, `_email`, `_icon`, `_thumbnailB64`, and `_lastSeenAt`.

Methods like `assign()`, `equals()`, `setThumbnailB64()`, and static utility methods such as `isValidId()`, `isValidName()`, `isValidEmail()`, and `isValidThumbnailB64()` ensure valid attribute values.

Other notable elements include `callAtob()` for base64 decoding, and static methods like `unknown()`, `safeAuthorLookup()`, and `isUnknown()` for handling unknown personas.

**Queue.ts**

This code defines a `Queue` class, a generic FIFO (First-In-First-Out) queue data structure implementation for the Boxer application.

The `Queue` class has two main properties: an array `queue` to store the elements and an `offset` to manage dequeuing efficiently.

The constructor initializes the `queue` as an empty array and sets `offset` to 0.

The class provides several methods:
- `getLength` returns the number of elements in the queue.
- `isEmpty` checks if the queue is empty.
- `enqueue` adds an item to the end of the queue.
- `dequeue` removes and returns the front item, handling memory cleanup if necessary.
- `peek` returns the front item without removing it.

**SharedEmbedding.ts**

The `SharedEmbedding` class in this module handles creating and managing shared embedding objects, which include an id, URL, conversation id, and a list of likes. It supports multiple constructor patterns including initializing from JSON.

The class uses `InvalidParameterError` for error handling and `MDynamicStreamable` is inherited for dynamic functionality. Other imported utilities include `throwIfUndefined` and `areSameShallowArray`.

Important functions and methods include:
- Constructors for different initialization patterns.
- `dynamicClassName`, `streamOut`, and `streamIn` for dynamic streaming.
- Getter and setter methods for private properties.
- Like and unlike management methods.
- Utility method `findInMap` to locate objects in a map by URL.
- Equality and assignment comparison methods.

Key classes:
- `SharedEmbedding`
- `Like`

Key functions:
- `findInMap`

**StreamingFramework.ts**

The `StreamingFramework` module is designed for streaming data to and from JSON within the Boxer application. It provides classes to handle streaming and managing dynamic objects.

The `MStreamable` class serves as the root for all derived types that can serialize and deserialize to and from JSON. It requires implementation of methods `streamOut` for JSON serialization and `streamIn` for deserialization.

The `MDynamicStreamable` class extends `MStreamable` to include dynamic creation based on class names stored in the stream. It introduces the `dynamicClassName`, `flatten`, and `resurrect` methods.

The `DynamicStreamableFactory` is responsible for dynamically creating instances of `MDynamicStreamable` based on the class name. It maintains a factory chain for class-based instantiation using a linked list setup.

**Important classes/functions:**
- `MStreamable`
- `MDynamicStreamable`
- `DynamicStreamableFactory`
- `streamOut()`
- `streamIn()`
- `dynamicClassName()`
- `flatten()`
- `resurrect()`
- `DynamicStreamableFactory.create()`

**Utilities.ts**

The module "Utilities" provides utility functions for the Boxer application. 

The `areSameDate` function compares two dates, checking if they are the same or if both are undefined.

The `areSameShallowArray` function compares two arrays shallowly, ensuring that each corresponding element in both arrays is strictly equal.

The `areSameDeepArray` function deeply compares two arrays by converting each element to a JSON string and checking equality.

The `throwIfUndefined` function from the `Asserts` module is used to ensure that date parameters in the `areSameDate` function are not undefined before comparison.

**UuidKeyGenerator.ts**

The `UuidKeyGenerator` module provides functionalities for generating and managing UUIDs and secrets in the Boxer application.

- The main class, `UuidKeyGenerator`, implements the `IKeyGenerator` interface and includes methods such as:
  - `generateKey()`: Generates a UUID using the `uuid` function.
  - `generateSecret()`: Creates a random secret encoded in Base64.
  - `couldBeAKey()`: Checks if a string looks like a valid UUID.
  - `saveSecret()`: Saves a secret string, using localStorage if available.
  - `matchesSavedSecret()`: Compares a given secret with the stored secret.
  - `haveSavedSecret()`: Checks if there is a stored secret.
  - `savedSecret()`: Retrieves the stored secret and ensures it is not null.

- Additional helper functions include `uuid()`, `generateUUID()`, and `looksLikeUuid()`, which facilitate UUID generation and validation.

- The module also includes dependency on external utility modules such as `Asserts` and `Errors`.

Key functions and classes:
- `UuidKeyGenerator`
- `NumberToUint32Array`
- `generateUUID`
- `uuid`
- `looksLikeUuid`
****************************************

****************************************
Api\src\functions\ReadMe.Salon.md
****************************************
**CheckSession.Azure.ts**

The module, `CheckSession`, is an Azure Function providing session validation via an HTTP endpoint, supporting both GET and POST methods. It verifies session keys against environment-configured valid sessions and grants anonymous access, requiring valid session key parameters for authentication.

The function `checkSession` validates session keys provided in request parameters against expected session keys stored in environment variables. Depending on the validity, the function returns either a 200 status, indicating success, or a 401 status, indicating authorization failure, with appropriate log messages.

Important classes or functions:
- `checkSession`
- `app.http`
- `isSessionValid`
- `sessionFailResponse`
- `defaultOkResponse`

**Chunk.Azure.ts**

- **Module Description**: The code defines an Azure Function module named `Chunk`. It provides a service to split input text into smaller, manageable chunks with configurable size and overlapping words. It integrates with the Braid API infrastructure.

- **Deployment and Development**: The function can be deployed via `func azure functionapp publish Braid-Api` and run locally with `npm start`.

- **Session Validation and Error Handling**: The chunking process involves session validation and error handling, returning standardized API responses.

- **Main Functions**:
  - `chunkText()`: Splits the input text into chunks based on specified chunk size and overlapping words.
  - `chunk()`: An asynchronous function that reads the text from the HTTP request, calls `chunkText()`, and returns the chunks in an HTTP response.

- **Utility Imports**: It imports utility functions like `isSessionValid`, `sessionFailResponse`, and `defaultErrorResponse`.

- **Model Usage**: Uses `getDefaultModel` from a shared source to access the chunking logic.

**Classify.Azure.ts**

This code module, `Classify`, is an Azure Function designed to provide text classification services using an AI model from OpenAI. It contains functionality for session validation, error handling, and response formatting.

The `decodeClassification` function translates an initial classification string into a human-readable format, returning "Unknown" if no match is found.

The `singleShotClassify` function asynchronously classifies provided text into predefined subject areas using an AI assistant. It uses the default chat model driver to generate a response and decodes the classification.

The `classify` function handles HTTP requests, validates sessions, processes requests, logs data, and returns a classification or error message. It supports both GET and POST methods with anonymous authentication level.

Key functions: `decodeClassification`, `singleShotClassify`, and `classify`.

**CosmosRepositoryApi.ts**

The CosmosRepositoryApi module provides utility functions for interacting with Azure Cosmos DB.

Important functions include:
- `getAuthorizationTokenUsingMasterKey`: Generates authorization tokens for various HTTP verbs using a master key.
- `storableToken`: Produces tokens to authorize specific HTTP requests to Cosmos DB documents.
- `makeStorableDeleteToken`: Creates a delete operation authorization token using the document ID.
- `makeStorablePostToken`: Produces tokens for POST operations.
- `makePostHeader`: Forms headers for POST requests.
- `makeDeleteHeader`: Generates headers for DELETE requests.
- `makePostQueryHeader`: Produces headers for POST queries, optionally including a continuation token.

These functions help create tokens and headers following Azure Cosmos DB’s authentication standards.


**Embed.Azure.ts**

This code defines an Azure Function module named `Embed` for text embedding using Azure AI services. It converts text into numerical vector representations (embeddings) and can automatically summarize texts that exceed the model's context window. The module includes retry logic for handling rate limiting and network errors and validates session authentication for all requests.

The main classes and functions in this module are as follows:
- `embed(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit>`: This function processes requests to embed text data and returns the embeddings or an authorization error.
- Utility functions like `isSessionValid`, `sessionFailResponse`, `defaultErrorResponse`, and `invalidRequestResponse` are imported for session validation and error handling.
- `getDefaultModel` and `getEmbeddingModelDriver` are used to get the default model and its driver for embedding operations.
- The module uses `recursiveSummarize` to reduce text length when necessary. 

This Azure Function can be published using "func azure functionapp publish Braid-Api" or run locally with "npm start".

**EnrichedChunkRepository.ts**

The code defines an in-memory implementation of the `IEnrichedChunkRepository` interface, used to store and query enriched data chunks based on their URLs or summaries. It includes functionality to calculate the cosine similarity between embeddings (vectors) and to determine if two URLs are from the same source, specifically handling YouTube and GitHub URLs.

Key functions include:
- `cosineSimilarity`: Calculates cosine similarity between two vectors.
- `lookLikeSameSource`: Determines if two URLs are from the same source.
- `lowestOfCurrent`: Finds the index of the least relevant chunk.
- `replaceIfBeatsCurrent`: Replaces a current chunk if a candidate chunk is more relevant.

The main class is `EnrichedChunkRepositoryInMemory`, which handles chunks lookup operations using various lookup methods such as `lookupRelevantFromSummary`, `lookupRelevantFromUrl`, and `lookupFromUrl`.

**EnrichedChunkRepositoryDb.ts**

The `EnrichedChunkRepositoryDb` class implements `IEnrichedChunkRepository`, providing a database-backed repository for enriched chunks with an in-memory cache.

The constructor initializes the class, sets up an in-memory repository, and manages data loading asynchronously from a database.

Key methods:
- `lookupRelevantFromSummary`: Searches for chunks relevant to the text in a query's summary.
- `lookupRelevantFromUrl`: Finds chunks relevant to a specific URL.
- `lookupFromUrl`: Retrieves an enriched chunk summary using its URL.

`loadStorables` is used to load chunk data from a database, which is then cached in-memory for faster access.

**EnrichedChunkRepositoryFactory.ts**

The module `EnrichedChunkRepositoryFactory` is designed to create and manage instances of `IEnrichedChunkRepository`. This factory ensures efficient performance by implementing the singleton pattern to create only one instance of each repository type.

The function `getEnrichedChunkRepository` returns an instance of `IEnrichedChunkRepository` based on the specified `EChunkRepository` enum value. For `kWaterfall` and `kBoxer` repository types, it returns an instance of `EnrichedChunkRepositoryDb`. If an instance already exists, the function returns this existing instance to avoid creating a new one.

Important Classes/Functions:
- `getEnrichedChunkRepository`: Retrieves the appropriate repository instance.
- `EnrichedChunkRepositoryDb`: A class representing the repository.
- `IEnrichedChunkRepository`: An interface for repository implementations.
- `EChunkRepository`: An enum for repository types.

**EnumerateModels.Azure.ts**

The code defines an Azure Function titled `EnumerateModels`. It focuses on providing details about installed models, including default, large, and small models, by returning them in a structured JSON format.

The `enumerateModels` function is the key component, handling HTTP requests and validating sessions using the `isSessionValid` function. If the session is valid, it processes the request to retrieve model information via the `getDefaultModel` function and returns it. If an error occurs, it logs the error and returns a default error response. If the session fails validation, it returns a session failure response.

Important imports include `app`, `HttpRequest`, `HttpResponseInit`, `InvocationContext`, `getDefaultModel`, `IEnumerateModelsRequest`, `IEnumerateModelsResponse`, `sessionFailResponse`, and `defaultErrorResponse`. 

The function is published to Azure with `func azure functionapp publish Braid-Api` and can run locally with `npm start`.

**EnumerateRepositories.Azure.ts**

**Important Functions and Classes:**
1. `enumerateRepositories`
2. `app.http`

**Summary:**
The module `EnumerateRepositories` is an Azure Function that retrieves details of installed repositories, namely Boxer and Waterfall repositories. It validates session authentication and handles errors during request processing.

**Function `enumerateRepositories`:**
- Asynchronously processes HTTP requests and validates the session using `isSessionValid`.
- If the session is valid, it logs the request data, constructs a response including repository details, and returns a status 200 response.
- If an error occurs during processing, it logs the error and returns a default error response.
- If the session validation fails, it logs the failure and returns a session failure response.

**Application Setup:**
- The module sets up an HTTP endpoint named `EnumerateRepositories` supporting GET and POST methods with anonymous authentication level using the Azure Function `app.http`.

**FindEnrichedChunks.Azure.ts**

This Azure Function module, named `FindEnrichedChunks`, retrieves enriched chunks based on URL and summary. 

It includes methods for session validation and error handling. 

Key functions are `FindRelevantEnrichedChunksFromSummary`, `FindRelevantEnrichedChunksFromUrl`, and `FindEnrichedChunkFromUrl`, each handling requests to find relevant chunks via HTTP calls. 

The module validates the session using the `isSessionValid` function, retrieves chunks from the `EnrichedChunkRepository`, and returns JSON responses. 

Error responses are managed by the `defaultErrorResponse` function, and `sessionFailResponse` handles invalid sessions. 

The app configuration defines the HTTP endpoints for each function.

**FindTheme.Azure.ts**

This module defines an Azure Function called `FindTheme` that analyzes multiple paragraphs of text to identify a common theme. 

It uses several imported utility functions for session validation (`isSessionValid`), session failure response (`sessionFailResponse`), invalid request response (`invalidRequestResponse`), and error handling (`defaultErrorResponse`). 

The primary function, `findTheme`, processes HTTP requests by reading the text and length criteria, validating the session, and invoking `findThemeCall` to perform the theme extraction. `findThemeCall`, in turn, uses the `modelDriver` API to generate and return the theme based on the provided text.

The function is exposed via HTTP endpoints for `GET` and `POST` requests.

**GenerateFluidToken.Azure.ts**

**GenerateFluidToken** module is an Azure Function that generates a Fluid token for authenticating requests to the Fluid framework.

**generateFluidToken** function:
- Validates session using `isSessionValid`.
- Checks for presence of `tenantId` and `key`.
- Processes the request to extract necessary parameters (`documentId`, `userId`, `userName`).
- Utilizes `generateToken` to generate the Fluid token with required user details and permissions ([ScopeType enum](DocRead, DocWrite, SummaryWrite)).
- Returns the generated token or appropriate error response.

**Utility.Azure** methods:
- `isSessionValid`
- `sessionFailResponse`
- `defaultErrorResponse`

**Dependencies**:
- @azure/functions
- @fluidframework/server-services-client
- Utility.Azure helper methods

**GenerateQuestion.Azure.ts**

This code is part of an Azure Function module named `GenerateQuestion`. It provides a method to generate a question based on a given summary and returns the question in a structured format. 

The main function, `generateQuestion`, handles HTTP requests, checks session validity, processes the request to generate a question, and includes error handling. If the session is valid, it parses the request data and calls the `askModel` function to generate a response.

The `askModel` function interacts with a model driver to generate a question based on a summary provided in the request.

Important classes/functions:
- `generateQuestion`
- `askModel`
- `isSessionValid`
- `sessionFailResponse`
- `defaultErrorResponse`

**IEnrichedChunkRepository.ts**

The module `IEnrichedChunkRepository` defines an interface for querying and retrieving enriched chunks. It provides methods to look up relevant chunks based on either a given summary or a URL.

**Important Methods:**
1. `lookupRelevantFromSummary()`: Takes an instance of `IChunkQueryRelevantToSummarySpec` and returns an array of `IRelevantEnrichedChunk` based on content similarity.
2. `lookupRelevantFromUrl()`: Takes an instance of `IChunkQueryRelevantToUrlSpec` and returns an array of `IRelevantEnrichedChunk` from other sources.
3. `lookupFromUrl()`: Takes an instance of `IChunkQueryRelevantToUrlSpec` and returns an `IEnrichedChunkSummary` or `undefined` for the whole chunk specified by the URL.

Additionally, the module sets default constants for search chunk count and cosine similarity threshold values.

**LoginWithLinkedIn.Azure.ts**

This module provides methods for logging in with LinkedIn through an Azure Function. The main function is `LoginWithLinkedIn`, which manages session validation and redirects users to LinkedIn for authentication. It also has robust error handling to ensure secure session verification.

Another important function, `redirectToLinkedIn`, constructs the LinkedIn authorization URL, incorporating necessary parameters and environment-specific redirect URIs.

The function `redirectBackHomeWithFullPath` processes the LinkedIn authentication response, exchanges the authorization code for an access token, retrieves the user profile, and redirects back to the home page with user details.

Finally, `processAuthFromLinkedIn` handles the post-authentication state, extracting necessary parameters from the request and initiating the redirection process.

Key functions include:
1. `LoginWithLinkedIn`
2. `redirectToLinkedIn`
3. `redirectBackHomeWithFullPath`
4. `processAuthFromLinkedIn`

**QueryModelWithEnrichment.ts**

The `QueryModelWithEnrichment` module allows querying an AI model with and without document enrichment using Azure Functions.

**Classes/Functions:**
1. `askModel`: Asynchronously processes both direct and enriched queries.
2. `queryModelWithEnrichment`: Handles HTTP requests, validates sessions, and processes queries.

The `askModel` function handles:
- Direct and enriched model queries in parallel.
- Document enrichment if the response meets a token threshold.
- Fetching relevant documents based on the enriched response.

The `queryModelWithEnrichment` function:
- Validates session integrity.
- Processes HTTP POST requests to perform model queries.
- Manages errors and logs activities.

Lastly, the Azure Functions setup integrates this into an HTTP endpoint named 'QueryModelWithEnrichment'.

**StorableActivity.Azure.ts**

This module, `StorableActivity`, is an Azure Function that handles CRUD operations for activity records. The primary operations included are retrieving, saving, removing, and fetching recent activities. 

The main functions are:
- `getActivity`: Retrieves and returns an activity based on the request attributes.
- `saveActivity`: Saves an activity record after validating the session key.
- `removeActivity`: Removes an activity record based on the request.
- `getRecentActivities`: Fetches and returns recent activity records.

The `app.http` method sets up HTTP triggers for these functions, allowing them to be invoked via HTTP requests, with all handlers set to be anonymous. The module also incorporates session authentication and error handling. 

Important dependencies include `@azure/functions` and `StorableApi.Cosmos`. The code includes third-party dependencies and built-in imports to ensure proper functioning and extendibility.


**StorableApi.Azure.ts**

The module `AzureStorableApi` defines Azure Functions HTTP endpoints that perform CRUD operations on IStorable objects stored in Azure Cosmos DB, acting as a REST API layer between HTTP clients and the database. 

The key features include session validation, request parsing, response formatting, custom transformers for data manipulation, error handling and logging, ID-based and functional key-based searches, and batch operations for retrieving recent storables.

Important functions in this module:
- `findStorableApi()`
- `getStorableApi()`
- `getStorableApiFromQuery()`
- `getStorableApiCommon()`
- `saveStorableApi()`
- `removeStorableApi()`
- `getRecentStorablesApi()`

These functions handle session validation, querying, transforming, saving, and removing storables, and formatting responses.

**StorableApi.Cosmos.ts**

The `CosmosStorableApi` module provides a high-level API for performing CRUD (Create, Read, Update, Delete) operations on Azure Cosmos DB collections. It also implements functionalities for querying Cosmos DB and supports data transformation during operations.

The module imports various third-party libraries like `axios` for HTTP requests and utilizes internal utility functions. Key constants are defined for partition keys and paths pertinent to different Cosmos DB collections.

`ICosmosStorableParams` and `ILoggingContext` interfaces are used for structuring collection parameters and logging interactions, respectively. The `AzureLogger` and `ConsoleLogger` classes offer logging capabilities to either Azure Functions or console logs.

Notable functions include `findStorable`, `loadStorable`, `saveStorable`, `removeStorable`, `loadRecentStorables`, and `loadStorables`, each designed for specific CRUD operations. These functions interact with Cosmos DB using HTTP requests and include features for optional data transformation through the `StorableTransformer` type.

**StorableChunk.Azure.ts**

The module, named `StorableChunk`, defines an Azure Function for handling chunk records. This module provides methods to retrieve, save, and remove chunk records, and fetch recent chunks. It ensures valid sessions via request query parameter authentication and includes error handling during request processing.

Key imported functions and constants include `chunkStorableAttributes` and APIs such as `findStorableApi`, `removeStorableApi`, `saveStorableApi`, `getStorableApi`, and `getRecentStorablesApi` from `StorableApi.Azure`.

Defined functions are `getChunk`, `findChunk`, `saveChunk`, `removeChunk`, and `getRecentChunks`, all handling specific HTTP requests for chunk operations and returning appropriate HTTP responses.

**StorablePage.Azure.ts**

**Important Classes or Functions:**
- `decompressHtml`
- `sendHtml`
- `getPage`
- `savePage`

**Summary:**
This module, `StorablePage`, is designed for Azure Functions to manage storable pages, providing methods for retrieving, saving, and removing page records. 

The module imports necessary libraries and internal methods for handling requests and interactions with Cosmos DB and Azure. It includes session authentication validation and error handling mechanisms.

The `decompressHtml` function decompresses the HTML content of a storable page, while the `sendHtml` function constructs and sends an HTTP response with the HTML content.

`GetPage` and `SavePage` functions handle HTTP requests for fetching and saving pages. They validate session keys, process JSON requests, and return HTTP responses accordingly.

**StudioForTeams.Azure.ts**

This code module, `StudioForTeams`, integrates Boxer's AI with Microsoft Teams via Azure Functions endpoints. It facilitates the processing of natural language queries from Teams, converting these requests to Boxer API formats, and returning enriched responses tailored for Teams users.

The main function, `boxerQuery`, handles HTTP requests, processes queries, and generates enriched responses, including document links and summaries. It uses the `askModel` function to interface with the Boxer backend.

A utility function `makeIconPath` generates favicon URLs for given source URLs. The module includes deployment commands for Azure and local environments, and it supports HTTP methods `GET` and `POST`.

**Summarize.Azure.ts**

This module, `Summarize.Azure`, provides the Azure Functions implementation for a text summarization API.

It handles HTTP requests, validates session tokens, and processes requests through the core summarization functionality using the `Summarize` module.

The `summarize` function is the main handler which processes the incoming HTTP request, validates sessions, parses input, invokes the text summarization, and returns the result to the client.

Key dependencies include `@azure/functions` for Azure Functions runtime, `./Summarize` for the core summarization logic, and `./Utility` for session validation and error handling.

The module supports both GET and POST methods for handling the summarization requests.

**Summarize.ts**

This code module provides functionality for text summarization using AI models. It includes features to split large texts into smaller, processable chunks with configurable overlap.

Key classes/functions:
1. `chunkText(text: string, overlapWords: number)`: Takes a piece of text and splits it into smaller chunks for easier processing.
2. `singleShotSummarize(persona: EPromptPersona, text: string, words: number)`: Summarizes the given text based on the specified persona and word count using an AI assistant.
3. `recursiveSummarize(persona: EPromptPersona, text: string, level: number, words: number)`: Generates a summary recursively to handle large documents and provides a concise summary.

Additional features include handling multiple summarization personas, managing API rate limits and retries, and input text validation. Deployment instructions are also provided for Azure and local execution.

**TestForSummariseFail.Azure.ts**

This module, `TestForSummariseFail`, validates the quality of AI-generated summaries by detecting failures such as incomplete text or error messages instead of proper summaries. It does so by analyzing the provided text and determining whether a valid summary can be produced.

The core functionality includes:
- The `testForSummariseFailCall` function, which sends a POST request to an Azure endpoint to analyze the text and utilizes retries for rate limits.
- The `testForSummariseFail` function, which validates session keys, processes HTTP requests, and returns the summary validation status or errors.

Deployment methods include publishing to Azure using `func azure functionapp publish Braid-Api` and running locally using `npm start`.

Key components involved are `app`, `HttpRequest`, `HttpResponseInit`, `InvocationContext` from "@azure/functions", and supporting functions/utilities from `Utility.Azure`.

**Utility.Azure.ts**

This module, named `Utility`, provides common utility functions for Azure Functions endpoints, including session validation, error responses, and standard HTTP response formatting. 

Key functions:

1. **isSessionValid**: Validates if a session provided in the HTTP request matches the session keys stored in environment variables, and logs the validation result.

2. **sessionFailResponse**: Returns an HTTP response with status code 401, indicating authorization failure.

3. **defaultOkResponse**: Returns a standard HTTP response with status code 200 (Ok).

4. **defaultErrorResponse**: Returns an HTTP response with status code 500, indicating a server error.

5. **invalidRequestResponse**: Returns an HTTP response for bad requests with status code 400, including a custom message.

6. **notFoundResponse**: Returns an HTTP response with status code 404, indicating a resource was not found.

Deployment can be done using the command `func azure functionapp publish Braid-Api` for Azure, or `npm start` for local execution.
****************************************
