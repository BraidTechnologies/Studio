****************************************
WaterfallBrowser\src\CommonTs\src\ClassifyApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from ClassifyApi.Types.yaml with typeconv
  version: '1'
  x-id: ClassifyApi.Types.yaml
  x-comment: >-
    Generated from src\ClassifyApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    IClassifyRequest:
      properties:
        text:
          title: IClassifyRequest.text
          type: string
        classifications:
          items:
            type: string
          title: IClassifyRequest.classifications
          type: array
      required:
        - text
        - classifications
      additionalProperties: false
      title: IClassifyRequest
      description: >-
        Represents a classification request object with text and
        classifications.
      type: object
    IClassifyResponse:
      properties:
        classification:
          title: IClassifyResponse.classification
          type: string
      required:
        - classification
      additionalProperties: false
      title: IClassifyResponse
      description: Interface for the classification response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Compress.ts
****************************************
import * as pako from 'pako';


/**
 * Compresses a string using deflate algorithm
 * @param input The string to compress
 * @returns Base64 encoded compressed string
 */
export function compressString(input: string): string {
   // Convert string to Uint8Array
   const data = new TextEncoder().encode(input);
   // Compress the data
   const compressed = pako.deflate(data);

   // Universal base64 encoding
   if (typeof window === 'undefined') {
      // Node.js environment
      return Buffer.from(compressed).toString('base64');
   } else {
      // Browser environment
      return btoa(String.fromCharCode.apply(null, Array.from(compressed)));
   }
}

/**
 * Decompresses a string that was compressed using compressString
 * @param input Base64 encoded compressed string
 * @returns Original decompressed string
 */
export function decompressString(input: string): string {
   try {
      // Universal base64 decoding
      let compressedData: Uint8Array;
      if (typeof window === 'undefined') {
         // Node.js environment
         compressedData = Buffer.from(input, 'base64');
      } else {
         // Browser environment
         compressedData = new Uint8Array(
            atob(input).split('').map(char => char.charCodeAt(0))
         );
      }

      // Decompress the data
      const decompressed = pako.inflate(compressedData);
      // Convert back to string
      return new TextDecoder().decode(decompressed);
   } catch (error) {
      throw new Error('Failed to decompress string: Invalid input');
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\EmbedApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the Embed API

/**
 * Interface for the embedding request object.
 */
export interface IEmbedRequest{

   text: string;
}

/**
 * Interface for the embedding response object.
 */
export interface IEmbedResponse {

   embedding: Array<number>;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\EmbedApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from EmbedApi.Types.yaml with typeconv
  version: '1'
  x-id: EmbedApi.Types.yaml
  x-comment: >-
    Generated from src\EmbedApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    IEmbedRequest:
      properties:
        text:
          title: IEmbedRequest.text
          type: string
      required:
        - text
      additionalProperties: false
      title: IEmbedRequest
      description: Interface for the embedding request object.
      type: object
    IEmbedResponse:
      properties:
        embedding:
          items:
            type: number
          title: IEmbedResponse.embedding
          type: array
      required:
        - embedding
      additionalProperties: false
      title: IEmbedResponse
      description: Interface for the embedding response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\EnrichedChunk.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the Chunk API

// We have an ID to distinguish different Chunk repostories. 
export enum EChunkRepository {

   kBoxer = "Boxer",
   kWaterfall = "Waterfall"
};

// Default is we only consider >= 50% relevant to present to the user (GPT4 seems to generate low scores ...)
export const kDefaultSimilarityThreshold = 0.5;

/**
 * Represents a Chunk enriched with specific properties.
 * This is a summary class that can be passed between client & server. 
 * @property {string} url - The URL associated with the chunk.
 * @property {string} text - The textual content of the chunk.
 * @property {string} summary - The summary content of the chunk.
 */
export interface IEnrichedChunkSummary {

   url: string;
   text: string;
   summary: string;
}

/**
 * Represents a Chunk enriched with specific properties.
  * This is a server side class only - its for storage. 
 * @property {string} id - The unique identifier of the chunk.
 * @property {Array<number>} embedding - An array of numbers representing the embedding of the chunk.
 */
export interface IEnrichedChunk extends IEnrichedChunkSummary {

   id: string;
   embedding: number[];
}

/**
 * Represents a relevant chunk with its associated relevance score.
 */
export interface IRelevantEnrichedChunk {

   chunk: IEnrichedChunkSummary;
   relevance: number;
}

/**
 * Defines the structure of a chunk query specification object.
 * 
 * @property {EChunkRepository} repositoryId - The ID of the repository to query.
 * @property {number} maxCount - The maximum number of results to retrieve.
 * @property {number} similarityThreshold - The threshold for similarity comparison.
 */
export interface IChunkQuerySpec {

   repositoryId: EChunkRepository;
   maxCount: number;
   similarityThreshold: number;
}

/**
 * Extends the IChunkQuerySpec interface to include a 'url' property of type string.
 */
export interface IChunkQueryRelevantToUrlSpec extends IChunkQuerySpec {

   url: string;
}

/**
 * Extends the IChunkQuerySpec interface to include a 'summary' property of type string.
 */
export interface IChunkQueryRelevantToSummarySpec extends IChunkQuerySpec {

   summary: string;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\EnrichedQuery.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the Query API

import { EChunkRepository, IRelevantEnrichedChunk} from "./EnrichedChunk";


/**
 * Defines the structure of a conversation element.
 */
export enum EConversationRole {

   kSystem = "system",
   kAssistant = "assistant",
   kUser = "user"
};

/**
 * Enum representing standard prompts for an AI assistant helping an application developer understand generative AI.
 * Includes prompts for initial questions, enrichment, follow-up questions, and generating questions.
 * Each prompt provides specific instructions and limitations for the AI assistant's responses.
 */
export enum EStandardPrompts {

   kOpenAiPersonaPrompt = "You are an AI assistant helping an application developer understand generative AI. You explain complex concepts in simple language, using Python examples if it helps. You limit replies to 50 words or less. If you don't know the answer, say 'I don't know'. If the question is not related to building AI applications, Python, or Large Language Models (LLMs),, say 'That doesn't seem to be about AI'.",
   kEnrichmentPrompt = "You will be provided with a question about building applications that use generative AI technology. Write a 50 word summary of an article that would be a great answer to the question. Enrich the summary with additional topics that the question asker might want to understand. Write the summary in the present tense, as though the article exists. If the question is not related to building AI applications, Python, or Large Language Models (LLMs), say 'That doesn't seem to be about AI'.\n",
   kFollowUpPrompt = "You will be provided with a summary of an article about building applications that use generative AI technology. Write a question of no more than 10 words that a reader might ask as a follow up to reading the article.",
   kFollowUpPrefix = "Article summary: ",
   kGenerateAQuestionPrompt = "You are an AI assistant helping an application developer understand generative AI. Based on the dialog presented as context, generate a 10 word question that is relevant to the subjects being discussed.\n"   
};


/**
 * Defines the structure of a conversation element.
 */
export interface IConversationElement {
   role: EConversationRole,
   content: string
}

/**
 * Defines the structure of an enriched query object.
 * Contains information about the repository, persona prompt, question prompt,
 * enrichment document prompt, and conversation history.
 */
export interface IEnrichedQuery {

   repositoryId : EChunkRepository;
   personaPrompt: string;
   enrichmentDocumentPrompt: string;
   similarityThreshold: number;
   maxCount: number;
   history: Array<IConversationElement>;
   question: string;
}

/**
 * Defines the structure of an enriched response object.
 * Contains an answer field of type string and a chunks field as an array of Relevant Enriched Chunk objects.
 */
export interface IEnrichedResponse {

   answer: string;
   chunks: Array<IRelevantEnrichedChunk>;
}

/**
 * Interface for generating questions query.
 * Contains persona prompt, question generation prompt, and summary fields.
 */
export interface IGenerateQuestionQuery {

   personaPrompt: string;
   questionGenerationPrompt: string;
   summary: string;
}

/**
 * Defines the structure of a response object for question generation.
 * Contains a property 'question' of type string representing the generated question.
 */
export interface IQuestionGenerationResponse {

   question: string;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\EnumerateModelsApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the EnumerateModels API

import {EChunkRepository} from './EnrichedChunk';

/**
 * Interface for the EnumerateModels request object.
 */
export interface IEnumerateModelsRequest{

}

/**
 * Interface for the EnumerateModels response object.
 */
export interface IEnumerateModelsResponse {

   defaultId: string;
   defaultEmbeddingId: string;   
   largeId: string;
   largeEmbeddingId: string;
   smallId: string;
   smallEmbeddingId: string;   
}

/**
 * Interface for the EnumerateRepositories request object.
 */
export interface IEnumerateRepositoriesRequest{

}

/**
 * Interface for the EnumerateModels response object.
 */
export interface IEnumerateReposotoriesResponse {

   repositoryIds: Array<EChunkRepository>
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\EnumerateModelsApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from EnumerateModelsApi.Types.yaml with typeconv
  version: '1'
  x-id: EnumerateModelsApi.Types.yaml
  x-comment: >-
    Generated from src\EnumerateModelsApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    IEnumerateModelsRequest:
      additionalProperties: false
      title: IEnumerateModelsRequest
      description: Interface for the EnumerateModels request object.
      type: object
    IEnumerateModelsResponse:
      properties:
        defaultId:
          title: IEnumerateModelsResponse.defaultId
          type: string
        defaultEmbeddingId:
          title: IEnumerateModelsResponse.defaultEmbeddingId
          type: string
        largeId:
          title: IEnumerateModelsResponse.largeId
          type: string
        largeEmbeddingId:
          title: IEnumerateModelsResponse.largeEmbeddingId
          type: string
        smallId:
          title: IEnumerateModelsResponse.smallId
          type: string
        smallEmbeddingId:
          title: IEnumerateModelsResponse.smallEmbeddingId
          type: string
      required:
        - defaultId
        - defaultEmbeddingId
        - largeId
        - largeEmbeddingId
        - smallId
        - smallEmbeddingId
      additionalProperties: false
      title: IEnumerateModelsResponse
      description: Interface for the EnumerateModels response object.
      type: object
    IEnumerateRepositoriesRequest:
      additionalProperties: false
      title: IEnumerateRepositoriesRequest
      description: Interface for the EnumerateRepositories request object.
      type: object
    IEnumerateReposotoriesResponse:
      properties:
        repositoryIds:
          items: {}
          title: IEnumerateReposotoriesResponse.repositoryIds
          type: array
      required:
        - repositoryIds
      additionalProperties: false
      title: IEnumerateReposotoriesResponse
      description: Interface for the EnumerateModels response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Environment.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import {EEnvironment, IEnvironment} from './IEnvironment';

/**
 * Class representing the Development Environment with methods to retrieve various API endpoints.
 * @class DevelopmentEnvironment
 */
export class DevelopmentEnvironment implements IEnvironment {

   name: string = EEnvironment.kLocal;

   checkSessionApi () : string {
      return "http://localhost:7071/api/CheckSession"; 
   }
   summariseApi () : string {
      return "http://localhost:7071/api/Summarize"; 

   }
   findThemeApi(): string {
      return "http://localhost:7071/api/FindTheme";
   }
   classifyApi () : string {
      return "http://localhost:7071/api/Classify"; 
   }
   chunkApi () : string {
      return "http://localhost:7071/api/Chunk"; 
   }
   embedApi () : string {
      return "http://localhost:7071/api/Embed"; 
   }
   testForSummariseFail(): string {
      return "http://localhost:7071/api/TestForSummariseFail";
   }
   saveActivityApi(): string {
      return "http://localhost:7071/api/SaveActivity"
   }
   removeActivityApi(): string {
      return "http://localhost:7071/api/RemoveActivity"
   }   
   getActivitiesApi(): string {
      return "http://localhost:7071/api/GetActivities"      
   }   
   getActivityApi(): string {
      return "http://localhost:7071/api/GetActivity"      
   }  
   findActivityApi(): string {
      return "http://localhost:7071/api/FindActivity"      
   }     
   loginWithLinkedInApi(): string {
      return "http://localhost:7071/api/LoginWithLinkedIn"; 
   }
   authFromLinkedInApi(): string {
      return "http://localhost:7071/api/ProcessAuthFromLinkedIn"; 
   }   
   boxerHome(): string {
      return "http://localhost:1337/boxer.html";
   }
   findRelevantEnrichedChunksFromUrl (): string {
      return "http://localhost:7071/api/FindRelevantEnrichedChunksFromUrl";
   }
   findRelevantEnrichedChunksFromSummary(): string{
      return "http://localhost:7071/api/FindRelevantEnrichedChunksFromSummary";
   }
   findEnrichedChunkFromUrl(): string {
      return "http://localhost:7071/api/FindEnrichedChunkFromUrl";      
   }
   queryModelWithEnrichment(): string {
      return "http://localhost:7071/api/QueryModelWithEnrichment";        
   }
   generateQuestion(): string{
      return "http://localhost:7071/api/GenerateQuestion";       
   }      
   generateFluidTokenApi(): string {
      return "http://localhost:7071/api/GenerateFluidToken";        
   } 
   fluidApi(): string {
      return  "http://localhost:7070";
   }
   fluidTenantId(): string {
      return "b9576484-5c2e-4613-bfdf-039948cdd521";
   }     
   studioForTeamsBoxer(): string {
      return "http://localhost:7071/api/StudioForTeams-Boxer";
   }   
   saveChunkApi() : string {
      return "http://localhost:7071/api/SaveChunk";
   }   
   removeChunkApi(): string{
      return "http://localhost:7071/api/RemoveChunk";
   }   
   getChunkApi(): string{
      return "http://localhost:7071/api/GetChunk";
   }    
   findChunkApi(): string {
      return "http://localhost:7071/api/FindChunk";
   }   
   getChunksApi(): string {
      return "http://localhost:7071/api/GetChunks";
   }         
   savePageApi() : string {
      return "http://localhost:7071/api/SavePage";
   }   
   getPageApi(): string {
      return "http://localhost:7071/api/GetPage";
   }   
   hostProtocolAndName(): string {
      return "http://localhost:7071";
   }
}

/**
 * Class representing the Staging Environment with methods to retrieve various API endpoints.
 * @class StagingEnvironment
 */
export class StagingEnvironment implements IEnvironment {

   name: string = EEnvironment.kStaging;

   checkSessionApi () : string {
      return "https://braid-api.azurewebsites.net/api/CheckSession";
   }
   summariseApi () : string {
      return "https://braid-api.azurewebsites.net/api/Summarize"; 
   }
   findThemeApi(): string {
      return "https://braid-api.azurewebsites.net/api/FindTheme";
   }
   classifyApi () : string {
      return "https://braid-api.azurewebsites.net/api/Classify"; 
   }
   chunkApi () : string {
      return "https://braid-api.azurewebsites.net/api/Chunk"; 
   }
   embedApi () : string {
      return "https://braid-api.azurewebsites.net/api/Embed"; 
   }   
   testForSummariseFail(): string {
      return "https://braid-api.azurewebsites.net/api/TestForSummariseFail";
   }   
   saveActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/SaveActivity";
   }  
   removeActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/RemoveActivity";
   }   
   getActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetActivity"      
   }     
   findActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/FindActivity"      
   }    
   getActivitiesApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetActivities";      
   }  
   loginWithLinkedInApi(): string {
      return "https://braid-api.azurewebsites.net/api/LoginWithLinkedIn"; 
   }
   authFromLinkedInApi(): string {
      return "https://braid-api.azurewebsites.net/api/ProcessAuthFromLinkedIn"; 
   }
   boxerHome(): string {
      return "https://braidapps.io/boxer.html";
   }   
   findRelevantEnrichedChunksFromUrl (): string {
      return "https://braid-api.azurewebsites.net/api/FindRelevantEnrichedChunksFromUrl";
   }
   findRelevantEnrichedChunksFromSummary(): string{
      return "https://braid-api.azurewebsites.net/api/FindRelevantEnrichedChunksFromSummary";
   }   
   findEnrichedChunkFromUrl(): string {
      return "https://braid-api.azurewebsites.net/api/FindEnrichedChunkFromUrl";      
   }   
   queryModelWithEnrichment(): string {
      return "https://braid-api.azurewebsites.net/api/QueryModelWithEnrichment";        
   }   
   generateQuestion(): string{
      return "https://braid-api.azurewebsites.net/api/GenerateQuestion";       
   }     
   generateFluidTokenApi(): string {
      return "https://braid-api.azurewebsites.net/api/GenerateFluidToken";        
   }    
   fluidApi(): string {
      return  "https://eu.fluidrelay.azure.com";
   }
   fluidTenantId(): string {
      return "b9576484-5c2e-4613-bfdf-039948cdd521";
   }    
   studioForTeamsBoxer(): string {
      return "https://braid-api.azurewebsites.net/api/StudioForTeams-Boxer";
   }
   saveChunkApi() : string{
      return "https://braid-api.azurewebsites.net/api/SaveChunk";
   }   
   removeChunkApi(): string{
      return "https://braid-api.azurewebsites.net/api/RemoveChunk";
   }   
   getChunkApi(): string{
      return "https://braid-api.azurewebsites.net/api/GetChunk";   
   }
   findChunkApi(): string{
      return "https://braid-api.azurewebsites.net/api/FindChunk";   
   }   
   getChunksApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetChunks";
   }         
   savePageApi() : string {
      return "https://braid-api.azurewebsites.net/api/SavePage";
   }   
   getPageApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetPage";
   }   
   hostProtocolAndName(): string {
      return "https://braid-api.azurewebsites.net";
   }
}

/**
 * Class representing a Production Environment with methods to retrieve various API endpoints.
 * @class ProductionEnvironment
 */
export class ProductionEnvironment implements IEnvironment {

   name: string = EEnvironment.kProduction;
   
   checkSessionApi () : string {
      return "https://braid-api.azurewebsites.net/api/CheckSession";
   }
   summariseApi () : string {
      return "https://braid-api.azurewebsites.net/api/Summarize"; 

   }
   findThemeApi(): string {
      return "https://braid-api.azurewebsites.net/api/FindTheme";
   }
   classifyApi () : string {
      return "https://braid-api.azurewebsites.net/api/Classify"; 
   }
   chunkApi () : string {
      return "https://braid-api.azurewebsites.net/api/Chunk"; 
   }   
   embedApi () : string {
      return "https://braid-api.azurewebsites.net/api/Embed"; 
   }    
   testForSummariseFail(): string {
      return "https://braid-api.azurewebsites.net/api/TestForSummariseFail";
   }      
   saveActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/SaveActivity"
   }    
   removeActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/RemoveActivity"
   }    
   getActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetActivity"      
   }     
   findActivityApi(): string {
      return "https://braid-api.azurewebsites.net/api/FindActivity"      
   }       
   getActivitiesApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetActivities"      
   }       
   loginWithLinkedInApi(): string {
      return "https://braid-api.azurewebsites.net/api/LoginWithLinkedIn"; 
   }
   authFromLinkedInApi(): string {
      return "https://braid-api.azurewebsites.net/api/ProcessAuthFromLinkedIn"; 
   }    
   boxerHome(): string {
      return "https://braidapps.io/boxer.html";
   }  
   findRelevantEnrichedChunksFromUrl (): string {
      return "https://braid-api.azurewebsites.net/api/FindRelevantEnrichedChunksFromUrl";
   }
   findRelevantEnrichedChunksFromSummary(): string {
      return "https:/braid-api.azurewebsites.net/api/FindRelevantEnrichedChunksFromSummary";   
   }
   findEnrichedChunkFromUrl(): string {
      return "https://braid-api.azurewebsites.net/api/FindEnrichedChunkFromUrl";      
   }    
   queryModelWithEnrichment(): string {
      return "https://braid-api.azurewebsites.net/api/QueryModelWithEnrichment";        
   } 
   generateQuestion(): string{
      return "https://braid-api.azurewebsites.net/api/GenerateQuestion";       
   }   
   generateFluidTokenApi(): string {
      return "https://braid-api.azurewebsites.net/api/GenerateFluidToken";        
   }
   fluidApi(): string {
      return  "https://eu.fluidrelay.azure.com";
   }
   fluidTenantId(): string {
      return "b9576484-5c2e-4613-bfdf-039948cdd521";
   }  
   studioForTeamsBoxer(): string {
      return "https://braid-api.azurewebsites.net/api/StudioForTeams-Boxer";
   }      
   saveChunkApi() : string{
      return "https://braid-api.azurewebsites.net/api/SaveChunk";
   }   
   removeChunkApi(): string{
      return "https://braid-api.azurewebsites.net/api/RemoveChunk";
   }   
   getChunkApi(): string{
      return "https://braid-api.azurewebsites.net/api/GetChunk";   
   }   
   findChunkApi(): string{
      return "https://braid-api.azurewebsites.net/api/FindChunk";   
   }      
   getChunksApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetChunks";
   }        
   savePageApi() : string {
      return "https://braid-api.azurewebsites.net/api/SavePage";
   }   
   getPageApi(): string {
      return "https://braid-api.azurewebsites.net/api/GetPage";
   }   
   hostProtocolAndName(): string {
      return "https://braid-api.azurewebsites.net";
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Errors.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

import { logApiError, logCoreError } from "./Logging";

/**
 * Represents an error thrown when an invalid parameter is encountered.
 * @param {string} message - The error message describing the invalid parameter.
 */
export class InvalidParameterError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = InvalidParameterError.name; // stack traces display correctly now

      logCoreError ("InvalidParameterError:" + (message ? message : ""), JSON.stringify (this));
   }
}

/**
 * Represents an error that occurs when an invalid operation is attempted.
 * @extends Error
 * @constructor
 * @param {string} [message] - The error message.
 */
export class InvalidOperationError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = InvalidOperationError.name; // stack traces display correctly now

      logCoreError ("InvalidOperationError:" + (message ? message : ""), JSON.stringify (this));      
   }
}


/**
 * Represents an error indicating an invalid state.
 * @param message - Optional. A message to describe the error.
 */
export class InvalidStateError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = InvalidStateError.name; // stack traces display correctly now

      logCoreError ("InvalidStateError:" + (message ? message : ""), JSON.stringify (this));      
   }
}

/**
 * Represents a custom error class for connection-related errors.
 * @class ConnectionError
 * @extends Error
 * @constructor
 * @param {string} [message] - The error message.
 */
export class ConnectionError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = ConnectionError.name; // stack traces display correctly now

      logApiError ("ConnectionError:" + (message ? message : ""), JSON.stringify (this));      
   }
}

/**
 * Represents an error related to the environment.
 * @param {string} [message] - The error message.
 */
export class EnvironmentError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = EnvironmentError.name; // stack traces display correctly now

      logCoreError ("EnvironmentError:" + (message ? message : ""), JSON.stringify (this));       
   }
}

/**
 * Represents an error that occurs when an assertion fails.
 * @param message - Optional. A message to describe the error.
 */
export class AssertionFailedError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = AssertionFailedError.name; // stack traces display correctly now

      logCoreError ("AssertionFailedError:" + (message ? message : ""), JSON.stringify (this));       
   }
}

/*
 
export class InvalidUnitError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = InvalidUnitError.name; // stack traces display correctly now
   }
}

export class InvalidFormatError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = InvalidFormatError.name; // stack traces display correctly now
   }
}

export class InvalidServerResponseError extends Error {
   constructor(message?: string) {
      super(message);
      // see: typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html
      Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
      this.name = InvalidServerResponseError.name; // stack traces display correctly now
   }
}

*/
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\FindEnrichedChunkApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import axios from 'axios';

import { Api } from './Api';
import { IEnvironment } from "./IEnvironment";
import { IChunkQueryRelevantToSummarySpec, IChunkQueryRelevantToUrlSpec, IEnrichedChunkSummary, IRelevantEnrichedChunk } from './EnrichedChunk';


/**
 * Class representing an API for finding enriched chunks.
 */
export class FindEnrichedChunkApi extends Api {

   /**
    * Initializes a new instance of the class with the provided environment and session key.
    * 
    * @param environment_ The environment settings to be used.
    * @param sessionKey_ The session key for authentication.
    */   
   public constructor(environment_: IEnvironment, sessionKey_: string) {
      super (environment_, sessionKey_);
   }  


   /**
    * Asynchronously finds an enriched chunk summary based on the provided URL query.
    * 
    * @param urlQuery - The URL query specifying the URL to search for the enriched chunk.
    * @returns An IEnrichedChunkSummary objects representing the found enriched chunk summary, or undefined.
    */
   async findChunkFromUrl (urlQuery: IChunkQueryRelevantToUrlSpec) : Promise<IEnrichedChunkSummary | undefined> {

      let apiUrl = this.environment.findEnrichedChunkFromUrl() + "?session=" + this.sessionKey.toString();
      var response: any;
      let empty = undefined;

      try {
         response = await axios.post(apiUrl, {
            data: urlQuery
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return empty;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return empty;      
      }          
   }

   /**
    * Asynchronously finds relevant enriched chunks based on the provided URL query.
    * 
    * @param urlQuery - The URL query specifying the URL to search for relevant enriched chunks.
    * @returns A Promise that resolves to an array of IRelevantEnrichedChunk objects representing the found relevant enriched chunks.
    */
   async findRelevantChunksFromUrl (urlQuery: IChunkQueryRelevantToUrlSpec) : Promise<Array<IRelevantEnrichedChunk>> {

      let apiUrl = this.environment.findRelevantEnrichedChunksFromUrl() + "?session=" + this.sessionKey.toString();
      var response: any;
      let empty = new Array<IRelevantEnrichedChunk> ();

      try {
         response = await axios.post(apiUrl, {
            data: urlQuery
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return empty;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return empty;      
      }          
   }

   /**
    * Asynchronously finds relevant enriched chunks based on the provided summary query.
    * 
    * @param urlQuery - The summary query specifying the summary to search for relevant enriched chunks.
    * @returns A Promise that resolves to an array of IRelevantEnrichedChunk objects representing the found relevant enriched chunks.
    */
   async findRelevantChunksFromSummary (urlQuery: IChunkQueryRelevantToSummarySpec) : Promise<Array<IRelevantEnrichedChunk>> {

      let apiUrl = this.environment.findRelevantEnrichedChunksFromSummary() + "?session=" + this.sessionKey.toString();
      var response: any;
      let empty = new Array<IRelevantEnrichedChunk> ();      

      try {
         response = await axios.post(apiUrl, {
            data: urlQuery
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return empty;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return empty;    
      }          
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\FindThemeApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the FindTheme API

/**
 * Interface for the find theme request object.
 */
export interface IFindThemeRequest{

   text: string;
   length: number;
}

/**
 * Interface for the find theme response object.
 */
export interface IFindThemeResponse {

   theme: string;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\FindThemeApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from FindThemeApi.Types.yaml with typeconv
  version: '1'
  x-id: FindThemeApi.Types.yaml
  x-comment: >-
    Generated from src\FindThemeApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    IFindThemeRequest:
      properties:
        text:
          title: IFindThemeRequest.text
          type: string
        length:
          title: IFindThemeRequest.length
          type: number
      required:
        - text
        - length
      additionalProperties: false
      title: IFindThemeRequest
      description: Interface for the find theme request object.
      type: object
    IFindThemeResponse:
      properties:
        theme:
          title: IFindThemeResponse.theme
          type: string
      required:
        - theme
      additionalProperties: false
      title: IFindThemeResponse
      description: Interface for the find theme response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Fluid.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the Fluid Token API

/**
 * Represents a Fluid user.
 * @interface
 * @property {boolean} local - if true, we are running locally - use local tentantID
 * @property {string} userId - The ID of the user making the request.
 * @property {string} userName - The name of the user making the request.
 
 */
export interface IFluidUser {

   local: boolean;
   userId: string;
   userName: string; 
}

/**
 * Represents a request for a Fluid token.
 * @interface
 * @property {string} documentId - ID of the shared document.
 */
export interface IFluidTokenRequest extends IFluidUser {

   documentId: string;   
}

/**
 * Represents a response to a request for a Fluid token.
 * @interface
 * @property {string} token - the token 
 */
export interface IFluidTokenResponse {

   token: string;   
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\FluidApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import axios, {AxiosInstance, AxiosStatic} from 'axios';
import axiosRetry from 'axios-retry';

import { Api } from './Api';
import { IEnvironment } from "./IEnvironment";
import { IFluidTokenRequest } from './Fluid';

export class FluidApi extends Api {

   /**
    * Initializes a new instance of the class with the provided environment and session key.
    * 
    * @param environment_ The environment settings to be used.
    * @param sessionKey_ The session key for authentication.
    */
   public constructor(environment_: IEnvironment, sessionKey_: string) {
      super (environment_, sessionKey_);
   }  

   /**
    * Asynchronously generates a token using the provided query parameters.
    * 
    * @param query - The request object containing documentId, userId, and userName.
    * @returns A Promise that resolves to a string if successful, otherwise undefined.
    */
   async generateToken (query: IFluidTokenRequest ) : Promise<string | undefined> {

      let apiUrl = this.environment.generateFluidTokenApi() + "?session=" + this.sessionKey;
      var response: any;
      let empty = undefined;

      try {
         // Up to 5 retries - it is a big fail if we cannot get a token for Fluid
         axiosRetry(axios as AxiosStatic | AxiosInstance, {
            retries: 5,
            retryDelay: axiosRetry.exponentialDelay,
            retryCondition: (error) => {
               return error?.response?.status === 429 || axiosRetry.isNetworkOrIdempotentRequestError(error);
            }
         });

         response = await axios.post(apiUrl, {
            data: query
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return empty;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return empty;      
      }          
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\FluidTokenProvider.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Implementation of the Fluid connection API

import { AzureRemoteConnectionConfig, AzureClientProps, ITokenProvider, ITokenResponse } from "@fluidframework/azure-client";

import { IEnvironment, EEnvironment } from "./IEnvironment";
import { FluidApi } from "./FluidApi";
import { IFluidUser, IFluidTokenRequest } from "./Fluid";
import { ConnectionError } from "./Errors";
import { getDefaultFluidEnvironment, getEnvironment } from "./IEnvironmentFactory";

/**
 * Token Provider implementation for connecting to an Azure Function endpoint for
 * Azure Fluid Relay token resolution.
 */
export class FluidTokenProvider implements ITokenProvider {
   
   private _api: FluidApi;
   private _user: IFluidUser;

   /**
    * Creates a new instance using configuration parameters.
    * @param environment The environment settings to be used.
    * @param sessionKey The session key for authentication 
    * @param user - User object
    */
   constructor(environment: IEnvironment, sessionKey: string, user: IFluidUser) {

      this._api = new FluidApi(environment, sessionKey);
      this._user = user;
   }

   public async fetchOrdererToken(tenantId: string, documentId?: string): Promise<ITokenResponse> {
      return {
         jwt: await this.getToken(tenantId, documentId),
      };
   }

   public async fetchStorageToken(tenantId: string, documentId: string): Promise<ITokenResponse> {
      return {
         jwt: await this.getToken(tenantId, documentId),
      };
   }

   private async getToken(tenantId: string, documentId: string | undefined): Promise<string> {

      let local = false;
      if (tenantId === "local")
         local = true;

      let request : IFluidTokenRequest = {
         local: local,
         userId: this._user.userId,
         userName: this._user.userName,
         documentId: documentId? documentId : ""
      }
      
      const response = await this._api.generateToken(request);
      if (!response)
         throw new ConnectionError("Unable to generate Fluid Token");
      return response;
   }
}

export class FluidConnectionConfig implements AzureRemoteConnectionConfig {

   tokenProvider: ITokenProvider; 
   endpoint: string;
   type: any;
   tenantId: string;
   documentId: string = "";

   /**
    * Creates a new instance using configuration parameters.
    * @param sessionKey The session key for authentication 
    * @param tokenRequest - Details to request a token
    * @param forceProduction - boolean, if true then connect to production else default
    */
   constructor(sessionKey: string, tokenRequest: IFluidTokenRequest, forceProduction: boolean) {

      let environment = getDefaultFluidEnvironment();
      if (forceProduction)
         environment = getEnvironment (EEnvironment.kProduction);

      if (environment.name === EEnvironment.kLocal)
         this.type = "local";
      else
         this.type = "remote";

      this.tenantId = environment.fluidTenantId();
      this.endpoint = environment.fluidApi();   
      if (tokenRequest.documentId)   
         this.documentId = tokenRequest.documentId;
      this.tokenProvider = new FluidTokenProvider (environment, sessionKey, tokenRequest);
   }
};

export class FluidClientProps implements AzureClientProps {
   connection: FluidConnectionConfig;

   /**
    * Creates a new instance using configuration parameters.
    * @param sessionKey The session key for authentication 
    * @param tokenRequest - Details to request a token
    * @param forceProduction - boolean, if true then connect to production else default
    */   
   constructor(sessionKey: string, tokenRequest: IFluidTokenRequest, forceProduction: boolean) {
      this.connection = new FluidConnectionConfig(sessionKey, tokenRequest, forceProduction);
   }
};
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\IEnvironment.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

export const BRAID_ENVIRONMENT_KEY = "BRAID_ENVIRONMENT"

export enum EEnvironment {

   kLocal = "Local", 
   kStaging = "Staging", 
   kProduction = "Production"   
};

export interface IEnvironment {

   name : string;
   hostProtocolAndName(): string;
   checkSessionApi () : string;
   summariseApi () : string;
   findThemeApi(): string;
   chunkApi () : string;   
   classifyApi () : string;
   embedApi() : string;
   testForSummariseFail(): string;
   saveActivityApi(): string;
   removeActivityApi(): string;
   getActivityApi(): string;   
   findActivityApi(): string;      
   getActivitiesApi(): string;
   boxerHome(): string;
   loginWithLinkedInApi(): string;
   authFromLinkedInApi(): string;
   findRelevantEnrichedChunksFromUrl(): string;
   findRelevantEnrichedChunksFromSummary(): string;   
   findEnrichedChunkFromUrl(): string;   
   queryModelWithEnrichment(): string;
   generateQuestion(): string;   
   generateFluidTokenApi(): string;
   fluidApi(): string;
   fluidTenantId(): string;
   studioForTeamsBoxer() : string;
   saveChunkApi() : string;
   removeChunkApi(): string;
   getChunkApi(): string;
   findChunkApi(): string;   
   getChunksApi(): string;   
   savePageApi() : string;   
   getPageApi(): string;   
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\IEnvironmentFactory.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

// Internal imports
import {EEnvironment, IEnvironment} from './IEnvironment';
import {DevelopmentEnvironment, StagingEnvironment, ProductionEnvironment} from './Environment';

declare var process : any;


/**
 * Returns the default environment based on the current execution context.
 * If running in a browser and on localhost, returns a DevelopmentEnvironment instance.
 * If the process environment variable BRAID_ENVIRONMENT is set to 'Local', returns a DevelopmentEnvironment instance.
 * Otherwise, returns a ProductionEnvironment instance.
 * @returns An instance of IEnvironment representing the default environment.
 */
export function getDefaultEnvironment () : IEnvironment  {

   // Use Development if we are running in Node.js
   if (typeof process !== 'undefined') {
      if (process.env.BRAID_ENVIRONMENT === EEnvironment.kLocal) {
         return new DevelopmentEnvironment();
      }
   }

   return new ProductionEnvironment();   
}

export function getDefaultFluidEnvironment () : IEnvironment  {

   let environment = getDefaultEnvironment();

   // If we are in Browser, and in localhost, use development
   if (typeof window !== 'undefined') {
      if (window.location.hostname === 'localhost') {
         environment = getEnvironment (EEnvironment.kLocal);
      }
   }
   return environment;
}

export function getDefaultLoginEnvironment () : IEnvironment  {

   let environment = getDefaultEnvironment();

   // If we are in Browser, and in localhost, use development
   if (typeof window !== 'undefined') {
      if (window.location.hostname === 'localhost') {
         environment = getEnvironment (EEnvironment.kLocal);
      }
   }
   return environment;
}

/**
 * Returns an instance of IEnvironment based on the provided EEnvironment type.
 * 
 * @param environmentString - The EEnvironment type to determine the environment.
 * @returns An instance of IEnvironment corresponding to the specified EEnvironment type.
 */
export function getEnvironment (environmentString: EEnvironment) : IEnvironment  {

   switch (environmentString) {
      case EEnvironment.kLocal:
         return new DevelopmentEnvironment();   

      case EEnvironment.kStaging:
         return new StagingEnvironment();   

      case EEnvironment.kProduction:
      default:
         return new ProductionEnvironment();
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\IModel.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

/**
 * Enum representing different sizes of a model.
 * 
 * @enum {string}
 */
export enum EModel {

   kSmall = "Small", 
   kLarge = "Large"  
};

/**
 * Represents an interface for a model with deployment information.
 * @interface
 */
export interface IModel {

   deploymentName : string;
   embeddingDeploymentName: string;
   contextWindowSize : number;
   fitsInContext(text: string): boolean;
   chunkText (text: string, chunkSize: number | undefined, overlapWords: number | undefined): Array<string>;
   estimateTokens (text: string): number;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\IModelFactory.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

// Internal imports
import {EModel, IModel} from './IModel';
import {GPT4} from './Model';

/**
 * Returns the default model which is an instance of GPT4oMini.
 * @returns {IModel} The default model.
 */
export function getDefaultModel () : IModel  {

   return new GPT4();   
}

/**
 * Returns an instance of IModel based on the provided EModel type.
 * 
 * @param model - The EModel type to determine the model.
 * @returns An instance of IModel corresponding to the specified EModel type.
 */
export function getModel (model: EModel) : IModel  {

   switch (model) {
      default:
         return new GPT4();
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\IPromptPersona.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd


export enum EPromptPersona {

   kArticleSummariser = "ArticleSummariser", 
   kCodeSummariser = "CodeSummariser"  
};

export interface IPromptPersona {

   name : string;
   systemPrompt: string;
   itemPrompt: string;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\IStorable.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

/**
 * Enum representing application names
 * 
 * @enum {string}
 */
export enum EStorableApplicationIds {

   kBoxer = "Boxer", 
   kWaterfall = "Waterfall"  
};

/**
 * Represents an interface for objects that can be stored.
 * 
 * Contains properties:
 * - id: string - the primary key of the stored object
 * - applicationId: string - identifies the application - one of the Enums above. 
 * - contextId: string - identifies the context, e.g., a conversation in Boxer
 * - userId: string | undefined - identifies the user; undefined if no direct user
 * - functionalSearchKey: string | undefined - used if the app needs to searcg by an attribute other than primary key
 * - created: Date - timestamp of creation
 * - amended: Date - timestamp of amendment
 * - className: string - class name; further fields are class-specific
 * - schemaVersion: string - allows versioning on the schema* 
 */
export interface IStorable {
                       
   id : string | undefined;  // id of the object that is stored - primary key. Can be undefined before the object is stored. 
   applicationId: string;    // Name of the application that generated and uses the chunk
   contextId: string | undefined;  // id to identify context - such as a conversation in Boxer. Undefined if application has no multi-tenanting. 
   functionalSearchKey: string | undefined; // Used if the app needs to searcg by an attribute other than primary key
   userId: string | undefined;     // id to identify the user. Undefined if there is no direct user. 
   created: string;      // creation timestamp as ISO date string
   amended: string;      // amend timestamp as ISO date string  
   className: string;  // className - all further fields are specific to the class
   schemaVersion: string;  // Allow versioning on the schema       
}

/**
 * Defines the structure of a query specification for searching for multiple records.
 * Includes the limit of records to return and the class name of the records to be stored / retrieved.
 */
export interface IStorableMultiQuerySpec {

   limit : number;          // limit of records to return
   className: string;       // what sort of records to return
}

/**
 * Defines the structure of a query specification for searching for a single record.
 * Includes the id (primary key) of the record. 
 */
export interface IStorableQuerySpec {

   id : string | undefined;  // id of the object that is stored - primary key.  
   functionalSearchKey: string | undefined; // If the id is unefined, this is used for the search
}

/**
 * Defines the structure of a query specification for searching for a single record.
 * Includes the id (primary key) of the record. 
 */
export interface IStorableOperationResult {

   ok :boolean;  // True if operation succeeeded
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Logging.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

/**
 * Logs a core error with the provided description and details.
 * 
 * @param description - A brief description of the core error.
 * @param details - Additional details related to the core error.
 * @returns void
 */
export function logCoreError (description: string, details: any) : void {

   console.error ("Core error:" + description + "Details:" + details.toString());
}

/**
 * Logs a database error with the provided description and details.
 * 
 * @param description - A brief description of the error.
 * @param details - Additional details about the error.
 * @returns void
 */
export function logDbError (description: string, details: any) : void {

   console.error ("Database error:" + description + "Details:" + details.toString());
}

/**
 * Logs an API error with the provided description and details.
 * 
 * @param description A brief description of the API error.
 * @param details Additional details related to the API error.
 * @returns void
 */
export function logApiError (description: string, details: any) : void {

   console.error ("Api error:" + description + "Details:" + details.toString());
}

/**
 * Logs API information.
 * 
 * @param description - A brief description of the API information.
 * @param details - Additional details about the API information.
 * @returns void
 */
export function logApiInfo (description: string, details: any) : void {

   console.log ("Api Info:" + description + "Details:" + details.toString());
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\LoginApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import axios from 'axios';

import { Api } from './Api';
import { IEnvironment } from "./IEnvironment";

/**
 * Represents a class for handling login operations.
 * @constructor
 * @param environment_ - The environment settings for the login operations.
 * @param sessionKey_ - The session key for the current login session.
 * @returns A Promise that resolves to a string indicating the login status.
 */
export class LoginApi extends Api {

   /**
    * Initializes a new instance of the class with the provided environment and session key.
    * 
    * @param environment_ The environment settings to be used.
    * @param sessionKey_ The session key for authentication.
    */
   public constructor(environment_: IEnvironment, sessionKey_: string) {
      super (environment_, sessionKey_);
   }  

   /**
    * Asynchronously logs in using LinkedIn API.
    * 
    * @returns A Promise that resolves to a string indicating the status after attempting to log in.
    */
   async login () : Promise<string> {

      let apiUrl = this.environment.loginWithLinkedInApi() + "?session=" + this.sessionKey.toString();
      var response: any;

      try {
         response = await axios.post(apiUrl, {
         });

         if (response.status === 200) {
            return "Redirecting...";
         }
         else {
            console.error ("Error, status: " + response.status);               
            return "";
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return "";       
      }          
   }
   
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\LooseObject.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

export interface LooseObject {
   [key: string]: any
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\Model.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import { InvalidParameterError } from './Errors';
import { IModel } from './IModel';
import GPT4Tokenizer from 'gpt4-tokenizer';

const tokenizer = new GPT4Tokenizer({ type: 'gpt3' });


/**
 * GPTM class implementing IModel interface.
 * Represents a model with specific deployment settings and context window sizes.
 */
export class GPT4 implements IModel {

   deploymentName: string;
   embeddingDeploymentName: string;
   contextWindowSize: number;
   contextWindowSizeWithBuffer: number;

   public constructor() {
      this.deploymentName = "GPT4o";
      this.embeddingDeploymentName = "Embed-3";
      this.contextWindowSize = 8192;
      this.contextWindowSizeWithBuffer = (8192 - 256)
   }

   /**
    * Checks if the given text fits within the context window size with buffer.
    * 
    * @param text The text to check if it fits within the context window size with buffer.
    * @returns True if the text fits within the context window size with buffer, false otherwise.
    */
   fitsInContext(text: string): boolean {

      let estimatedTokens = tokenizer.estimateTokenCount(text);

      if (estimatedTokens < this.contextWindowSizeWithBuffer)
         return true;
      return false;
   }

   /**
    * Splits the input text into chunks based on the specified overlap of words.
    * 
    * @param text The text to be chunked.
    * @param overlapWords The number of overlapping words between consecutive chunks. If undefined, we chunk with no obverlap. 
    * @returns An array of strings representing the chunked text.
    */
   chunkText(text: string, chunkSize: number | undefined, overlapWords: number | undefined): Array<string> {

      let effectiveChunkSize = chunkSize
         ? Math.min(this.contextWindowSizeWithBuffer, chunkSize)
         : this.contextWindowSizeWithBuffer;

      if (overlapWords) {

         if (overlapWords > effectiveChunkSize)
            throw new InvalidParameterError ("Overlap window size cannot be bigger than chunk size")

         // If the users requests overlapping chunks, we divide the text into pieces the size of the overlap, then glue them back
         // together until we fill a buffer. 
         let chunked = tokenizer.chunkText(text, Math.floor(overlapWords * 2));
         let chunks = new Array<string>();

         let workingBufferText = "";
         let workingBufferTokens = 0;
         let lastChunkText = "";
         let lastChunkTokens = 0;

         for (let i = 0; i < chunked.length; i++) {

            let thisChunkText = chunked[i].text;
            let thisChunkTokens = tokenizer.estimateTokenCount(thisChunkText);

            if (workingBufferTokens + thisChunkTokens < effectiveChunkSize) {
               // If we are within buffer size, we just accumulate
               workingBufferText = workingBufferText + thisChunkText;
               workingBufferTokens = workingBufferTokens + thisChunkTokens;
            }
            else {
               // If we are outside buffer, we save the current chunk and build the start of the next one
               chunks.push(workingBufferText);

               workingBufferText = lastChunkText + thisChunkText
               workingBufferTokens = lastChunkTokens + thisChunkTokens;
            }

            // If we have reached the last chunk, we have to save it. 
            if (i === chunked.length - 1) {
               chunks.push(workingBufferText);
            }

            lastChunkTokens = thisChunkTokens;
            lastChunkText = thisChunkText;
         }
         return chunks;
      }
      else {
         let chunked = tokenizer.chunkText(text, effectiveChunkSize);

         let chunks = new Array<string>();

         for (let i = 0; i < chunked.length; i++) {
            chunks.push(chunked[i].text);
         }
         return chunks;
      }
   }

   /**
    * Estimates the number of tokens in the provided text using the tokenizer.
    * 
    * @param text The text for which to estimate the number of tokens.
    * @returns The estimated number of tokens in the text.
    */
   estimateTokens(text: string): number {

      return tokenizer.estimateTokenCount(text);
   }
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\PageRepositoryApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd

import { Api } from './Api';
import { IEnvironment } from "./IEnvironment";
import { IStorable} from "./IStorable";
import { StorableRepostoryApi, IStorablePageRepostoryApiWrapper} from './StorableRepositoryApi';
import { compressString, decompressString } from './Compress';
/**
 * Represents an API for the Page repository
 * 
 * @param {EEnvironment} environment_ - The environment to use for saving Pages.
 * @param {string} sessionKey_ - The session key for authentication.
 * 
 * @method save - Saves a record to the Page API.
 * Does not provide a 'load' as Pages are loaded directly into the browser
 */
export class PageRepostoryApi extends Api implements IStorablePageRepostoryApiWrapper {
   
   private storableApi: StorableRepostoryApi;

   /**
    * Initializes a new instance of the class with the provided environment and session key.
    * 
    * @param environment_ The environment settings to be used.
    * @param sessionKey_ The session key for authentication.
    */
   public constructor(environment_: IEnvironment, sessionKey_: string) {
      super (environment_, sessionKey_);

      this.storableApi = new StorableRepostoryApi();      
   }  

   /**
    * Asynchronously saves a record to the page repository API.
    * 
    * @param record - The record to be saved, must implement the IStoredPage interface.
    * @returns A Promise that resolves when the record is successfully saved, or rejects with an error.
    */
   async save (record: IStorable) : Promise<boolean> {

      let apiUrl = this.environment.savePageApi() + "?session=" + this.sessionKey.toString();
      return this.storableApi.save (record, apiUrl);             
   }  

   /**
    * Compresses a string using deflate algorithm
    * @param input The string to compress
    * @returns Base64 encoded compressed string
    */
   public compressString(input: string): string {
      return compressString(input);
   }

   /**
    * Decompresses a string that was compressed using compressString
    * @param input Base64 encoded compressed string
    * @returns Original decompressed string
    */
   public decompressString(input: string): string {
      return decompressString(input);
   }

}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\PageRepositoryApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the PageRepository API

import { IStorable, IStorableQuerySpec} from "./IStorable";

/**
 * Interface representing a web page Chunk.
 * 
 * Core data for a Page:
 * - html: HTML content
 */
export interface IStoredPage extends IStorable {

   html: string;       // HTML content
}

// We have an explicit type for the input so code generators can identify it to generate test code
export interface IStoredPageRequest extends IStorableQuerySpec {

}

// We have an explicit type for the output so code generators can identify it to generate test code
export interface IStoredPageResponse extends IStoredPage {

}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\PageRepositoryApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from PageRepositoryApi.Types.yaml with typeconv
  version: '1'
  x-id: PageRepositoryApi.Types.yaml
  x-comment: >-
    Generated from src\PageRepositoryApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
components:
  schemas:
    IStoredPage:
      properties:
        html:
          title: IStoredPage.html
          type: string
      required:
        - html
      additionalProperties: false
      title: IStoredPage
      description: "Interface representing a web page Chunk.\r\n\r\nCore data for a Page:\r\n- html: HTML content"
      type: object
    IStoredPageRequest:
      additionalProperties: false
      title: IStoredPageRequest
      type: object
    IStoredPageResponse:
      properties:
        html:
          title: IStoredPage.html
          type: string
      required:
        - html
      additionalProperties: false
      title: IStoredPageResponse, IStoredPage
      description: "Interface representing a web page Chunk.\r\n\r\nCore data for a Page:\r\n- html: HTML content"
      type: object
    StoredPageApi:
      title: StoredPageApi
    paths:
      /functions:
        get:
          operationId: get_page
          summary: Returns a page. 
          description: Returns a page. 
          parameters:
            - request: request
              in: query
              description: A spec for a Page
              schema:
                type: IStoredPageRequest
              required: true
          responses:
            '200':
              description: A Page
              content:
                application/json:
                  schema:
                    type: IStoredPageResponse    
            '400':
              description: An error 
              content:
                application/json:
                  schema:
                    type: string
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\PromptPersona.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd


import { EPromptPersona } from "./IPromptPersona";
import { IPromptPersona } from "./IPromptPersona";

export const ArticleSummariserPersona: IPromptPersona = {

   name: EPromptPersona.kArticleSummariser,
   systemPrompt: "",
   itemPrompt: ""
};

export const CodeSummariserPersona: IPromptPersona = {

   name: EPromptPersona.kCodeSummariser,
   systemPrompt: "",
   itemPrompt: ""
};
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\QueryModelApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import axios from 'axios';

import { Api } from './Api';
import { IEnvironment } from "./IEnvironment";
import { IEnrichedQuery, IEnrichedResponse, IGenerateQuestionQuery, IQuestionGenerationResponse } from './EnrichedQuery';

/**
 * Represents a QueryModelApi class that interacts with the specified environment to query models with enrichment and generate questions.
 * @constructor
 * @param environment_ - The environment to interact with.
 * @param sessionKey_ - The session key for authentication.
 */
export class QueryModelApi extends Api {

   /**
    * Initializes a new instance of the class with the provided environment and session key.
    * 
    * @param environment_ The environment settings to be used.
    * @param sessionKey_ The session key for authentication.
    */
   public constructor(environment_: IEnvironment, sessionKey_: string) {
      super (environment_, sessionKey_);
   }  

   /**
    * Asynchronously queries the model with enrichment data.
    * 
    * @param query - The enriched query data to be sent.
    * @returns A promise that resolves to the enriched response data, or undefined if an error occurs.
    */
   async queryModelWithEnrichment (query: IEnrichedQuery) : Promise<IEnrichedResponse | undefined> {

      let apiUrl = this.environment.queryModelWithEnrichment() + "?session=" + this.sessionKey.toString();
      var response: any;
      let empty = undefined;

      try {
         response = await axios.post(apiUrl, {
            data: query
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return empty;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return empty;      
      }          
   }

   /**
    * Asynchronously generates a question based on the provided query data.
    * 
    * @param query - The data containing persona prompt, question generation prompt, and summary.
    * @returns A promise that resolves to the generated question response, or undefined if an error occurs.
    */
   async generateQuestion (query: IGenerateQuestionQuery) : Promise<IQuestionGenerationResponse | undefined> {

      let apiUrl = this.environment.generateQuestion() + "?session=" + this.sessionKey.toString();
      var response: any;
      let empty = undefined;

      try {
         response = await axios.post(apiUrl, {
            data: query
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return empty;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return empty;      
      }          
   }   
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\ReadMe.Salon.md
****************************************
**ActivityRepositoryApi.ts**

The `ActivityRepositoryApi` class extends the `Api` class and implements the `IStorableRepostoryApiWrapper` interface. It interacts with an activity data repository using the provided environment settings and session key for authentication.

The class provides methods to asynchronously load, find, save, and remove activity records. The `load` method retrieves a record by its ID, while the `find` method searches for a record using a functional search key. The `save` method saves a new record, and the `remove` method deletes a record. The `recent` method retrieves an array of recent activity records based on query specifications.

**Api.ts**

This code defines an `Api` class that interacts with a specified environment using a session key for authentication.

It includes a constructor that initializes these values and provides accessor methods to retrieve the environment and session key.

The class itself is a superclass, serving as a base for more specific API classes which will use these common properties. 

This code uses TypeScript and imports Axios for HTTP requests.

**Asserts.ts**

The provided code defines three TypeScript utility functions that throw errors if certain conditions are met.

The `throwIfUndefined` function throws an `AssertionFailedError` if the input `x` is `undefined`.

The `throwIfNull` function throws an `AssertionFailedError` if the input `x` is `null`.

The `throwIfFalse` function throws an `AssertionFailedError` if the boolean input `x` is `false`.

**ChunkApi.Types.ts**

An interface, IChunkRequest, defines the structure for chunk request API with properties such as 'text' for the content, 'chunkSize' for the token size of each chunk, and 'overlapWords' for the number of overlapping words between chunks.

Another interface, IChunkResponse, specifies the structure for the response, which includes an array of text chunks.

**ChunkRepositoryApi.ts**

The `ChunkRepositoryApi` class interacts with an API to manage records in a Chunk repository. It uses the `StorableRepositoryApi` for performing CRUD operations.

The constructor initializes the class with environment settings and a session key for authentication.

The `load` method retrieves a record using its ID.

The `find` method searches for a record based on a functional search key.

The `save` method saves a record to the repository.

The `remove` method deletes a record identified by its ID.

The `recent` method fetches recent records based on query specifications.

**ChunkRepositoryApi.Types.ts**

The ChunkRepository API includes various interfaces for handling and storing different data elements.

The `IStoredEmbedding` interface stores embeddings with a model ID and an array of numbers representing the embedding.

The `IStoredTextRendering` interface defines the structure for a stored text rendering object.

The `IStoredChunk` interface represents a chunk of data, including properties like parentChunkId, originalText, URL, stored embeddings, stored summaries, stored titles, and related chunk IDs. These elements enable the reconstruction and reference of data within the repository.

**ClassifyApi.Types.ts**

A classification request object in the Chunk API includes text to be classified and an array of classifications.

The classification response object consists of a single classification result.

**Compress.ts**

The provided code defines two functions for handling string compression and decompression using the deflate algorithm.

The `compressString` function takes a string as input and returns a base64 encoded compressed string. It uses TextEncoder to convert the string to a Uint8Array, then compresses it with pako.deflate. It handles base64 encoding differently for Node.js and browser environments.

The `decompressString` function takes a base64 encoded compressed string and returns the original decompressed string. It base64 decodes the input, decompresses it with pako.inflate, and then converts it back to a string using TextDecoder. If decompression fails, it throws an error.

**EmbedApi.Types.ts**

The provided text defines the interfaces for request and response objects of Embed API. 

The `IEmbedRequest` interface includes a single property `text` which is of type string. 

The `IEmbedResponse` interface comprises an `embedding` property which is an array of numbers.

**EnrichedChunk.ts**

The text defines the data structures and interfaces for the Chunk API by Braid Technologies Ltd. Different chunk repositories are distinguished using the `EChunkRepository` enum, with a default similarity threshold of 0.5.

`IEnrichedChunkSummary` includes properties such as URL, text, and summary for client-server communication. `IEnrichedChunk` extends this interface with an additional property for a unique identifier and embedding.

`IChunkQuerySpec` specifies the structure for chunk query objects, including repository ID, maximum count of results, and similarity threshold. Extensions of this interface include `IChunkQueryRelevantToUrlSpec` and `IChunkQueryRelevantToSummarySpec`, for URL and summary relevance, respectively.

**EnrichedQuery.ts**

The text provides various definitions and structures for the Query API, primarily dealing with AI-generated content and interactions.

First, it defines roles in a conversation, specifying whether the speaker is the system, an assistant, or a user.

Second, it lists standard prompts that an AI assistant uses to help application developers understand generative AI. These prompts include generating concise explanations, summarizing articles, creating follow-up questions, and generating questions based on dialogue.

Third, it details the structure of conversation elements, enriched queries, enriched responses, question generation queries, and question generation responses, specifying the fields for each object in the API.

**EnumerateModelsApi.Types.ts**

The provided text defines interfaces for an API related to model and repository enumeration. 

One interface, `IEnumerateModelsRequest`, appears to be empty and is likely used to structure requests for enumerating models.

Another interface, `IEnumerateModelsResponse`, outlines the expected structure of a response, including fields for default, large, and small model IDs and their corresponding embedding IDs.

An interface, `IEnumerateRepositoriesRequest`, is also defined for repository request enumeration and similarly appears to be empty.

Lastly, `IEnumerateRepositoriesResponse` details the expected response structure, which includes an array of repository IDs identified as `EChunkRepository`.

**Environment.ts**

The provided text defines three classes representing different environments: DevelopmentEnvironment, StagingEnvironment, and ProductionEnvironment. Each class implements various methods to retrieve different API endpoints. 

The DevelopmentEnvironment class uses "http://localhost:7071" for accessing the APIs during local development.

The StagingEnvironment class uses "https://braid-api.azurewebsites.net" for its API endpoints to simulate a pre-production setup.

The ProductionEnvironment class similarly uses "https://braid-api.azurewebsites.net" for its APIs, representing the live production environment.

Each class also specifies a different URL for the `fluidApi()` method and has an associated `fluidTenantId()`.

**Errors.ts**

The `InvalidParameterError` class represents an error when an invalid parameter is encountered and logs the error message using `logCoreError`.

The `InvalidOperationError` class represents an error occurring from an invalid operation, extending the Error class and logging the error accordingly.

The `InvalidStateError` class handles errors indicating an invalid state and logs the error details.

The `ConnectionError` class represents errors related to connections and uses `logApiError` for logging.

The `EnvironmentError` class deals with errors related to the environment and logs the error message.

The `AssertionFailedError` class is used for errors resulting from assertion failures and logs the error details.

**FindEnrichedChunkApi.ts**

The `FindEnrichedChunkApi` class is used for finding enriched chunks via an API. 

It initializes with environment settings and a session key. 

The `findChunkFromUrl` method asynchronously gets an enriched chunk summary based on a URL query.

The `findRelevantChunksFromUrl` method asynchronously fetches relevant enriched chunks based on a URL query.

The `findRelevantChunksFromSummary` method retrieves relevant enriched chunks based on a summary query. 

Each method sends a POST request to the appropriate API endpoint and handles errors by logging them, returning undefined or an empty array when unsuccessful.

**FindThemeApi.Types.ts**

The provided text defines interfaces for a FindTheme API request and response. 

The `IFindThemeRequest` interface includes two properties: `text`, which is a string, and `length`, which is a number.

The `IFindThemeResponse` interface contains one property: `theme`, which is a string.

**Fluid.ts**

Braid Technologies Ltd has created definitions for the data elements in the Fluid Token API.

The `IFluidUser` interface represents a Fluid user, indicating if the user is running locally, along with their ID and name.

The `IFluidTokenRequest` interface, which extends `IFluidUser`, includes the ID of the shared document for which a Fluid token is requested.

The `IFluidTokenResponse` interface contains the token string response for the requested Fluid token.

**FluidApi.ts**

FluidApi is a class that extends the Api class and is used for generating tokens required for authentication. 

The constructor initializes the instance with the provided environment settings and session key.

The `generateToken` method is asynchronous and generates a token using query parameters such as documentId, userId, and userName. 

The method makes use of axios for HTTP requests and axiosRetry for retrying failed requests. It attempts up to 5 retries if a network issue or a 429 status occurs and returns the token if the request is successful or logs an error otherwise.

**FluidTokenProvider.ts**

The FluidTokenProvider class provides an implementation to connect to an Azure Function endpoint for resolving Azure Fluid Relay tokens. It uses an instance of FluidApi and user details to authenticate and generate tokens for orderer and storage.

The FluidConnectionConfig class sets up the connection configuration for Fluid, determining the environment (local or remote) and endpoints, and initializes a FluidTokenProvider for token generation.

The FluidClientProps class initializes using FluidConnectionConfig, and helps configure connection properties, using session keys and token requests, and deciding whether to connect to a production environment or the default.

**IEnvironment.ts**

The provided code defines a module managing environment configurations with specific APIs. 

`BRAID_ENVIRONMENT_KEY` is set as "BRAID_ENVIRONMENT".

`EEnvironment` enumerates three environment types: Local, Staging, and Production.

The `IEnvironment` interface includes methods for various API endpoints, such as `checkSessionApi`, `summariseApi`, `findThemeApi`, `chunkApi`, `classifyApi`, `embedApi`, and others focused on activity and chunk management, LinkedIn authentication, fluid APIs, and question generation.

**IEnvironmentFactory.ts**

The code defines functions that determine the default environment settings for a system. 

The `getDefaultEnvironment` function checks the execution context and returns a `DevelopmentEnvironment` if running in Node.js with the environment variable set to 'Local'; otherwise, it returns a `ProductionEnvironment`.

The `getDefaultFluidEnvironment` and `getDefaultLoginEnvironment` functions first obtain the default environment and modify it to `DevelopmentEnvironment` if running on a browser with 'localhost'. 

The `getEnvironment` function returns the appropriate environment instance based on the provided `EEnvironment` type.

**IModel.ts**

An enum `EModel` represents different sizes of a model, with `Small` and `Large` values.

An interface `IModel` defines the structure for a model with deployment details, such as deployment names, context window size, and methods for fitting text into context, chunking text, and estimating tokens.

**IModelFactory.ts**

The code provides two main functions related to models:

The `getDefaultModel` function returns an instance of the default model, which is a `GPT4` object.

The `getModel` function returns an instance of a model based on the provided `EModel` type. By default, it returns an instance of `GPT4`.

**IPromptPersona.ts**

The document contains an enumeration (`enum`) called `EPromptPersona`, which includes two values: `kArticleSummariser` and `kCodeSummariser`. These likely represent different personas for summarizing articles and code respectively.

There is also an interface called `IPromptPersona`, which includes three properties: `name` of type string, `systemPrompt` of type string, and `itemPrompt` of type string. This interface likely defines the structure for objects that will implement the prompt personas.

**IStorable.ts**

The document defines a set of TypeScript interfaces and enumerations for an application dealing with storable objects.

It introduces `EStorableApplicationIds`, an enumeration representing application names such as "Boxer" and "Waterfall".

The `IStorable` interface represents objects that can be stored, detailing properties like `id`, `applicationId`, `contextId`, `userId`, `created`, `amended`, `className`, and `schemaVersion`.

The `IStorableMultiQuerySpec` interface specifies the structure for querying multiple records, including the limit on the number of records and the class name of the records.

The `IStorableQuerySpec` interface is for querying a single record with either an `id` or `functionalSearchKey`.

Finally, the `IStorableOperationResult` interface indicates the success of an operation with a boolean `ok`.

**Logging.ts**

These functions log different types of errors and information:

1. The `logCoreError` function logs core errors with a description and detailed information.
2. The `logDbError` function logs database errors with a description and detailed information.
3. The `logApiError` function logs API errors with a description and detailed information.
4. The `logApiInfo` function logs API information with a description and detailed information.

**LoginApi.ts**

The `LoginApi` class handles login operations, initializing with environment settings and a session key.

An asynchronous `login` method logs in using the LinkedIn API. If successful, it returns "Redirecting...". On failure, it logs the error and returns an empty string.

**Model.ts**

The GPT4 class implements the IModel interface and includes methods to manage the context window size and chunk text. 

The constructor sets default deployment names and context window sizes.

The `fitsInContext` method checks if a given text fits within the context window size, considering a buffer.

The `chunkText` method chunks the input text into segments, allowing for overlap between chunks if specified. 

The `estimateTokens` method estimates the number of tokens in a provided text using the GPT-4 tokenizer.

**PageRepositoryApi.ts**

The `PageRepostoryApi` class extends the `Api` class and implements the `IStorablePageRepostoryApiWrapper` interface. It represents an API for the Page repository and is responsible for saving records.

The constructor initializes the `PageRepostoryApi` with environment settings and a session key for authentication. It also initializes an instance of `StorableRepostoryApi`.

The `save` method saves a record to the page repository API asynchronously, using a specified API URL. 

The `compressString` method compresses a string using the deflate algorithm and returns a base64 encoded compressed string.

The `decompressString` method decompresses a base64 encoded compressed string back to its original form.

**PageRepositoryApi.Types.ts**

This document defines interfaces for a PageRepository API by Braid Technologies Ltd. 

The `IStoredPage` interface represents a web page chunk, containing core data such as HTML content.

The `IStoredPageRequest` interface serves as a request type for input, enabling code generators to identify it for generating test code.

The `IStoredPageResponse` interface extends `IStoredPage`, representing the output to be used for test code generation by code generators.

**PromptPersona.ts**

Braid Technologies Ltd has created two personas, the Article Summariser and the Code Summariser, each with specified names but currently empty system and item prompts.

**QueryModelApi.ts**

The **QueryModelApi** class is designed to interface with a given environment to query models with enriched data and generate questions.

The constructor initializes the class with specified environment settings and authentication session key.

The **queryModelWithEnrichment** method sends an asynchronous request with enriched query data and returns the response data or undefined if an error occurs.

The **generateQuestion** method sends an asynchronous request with provided query data to generate a question, returning the response data or undefined if an error occurs.

**SessionApi.ts**

The `SessionApi` class extends the `Api` class and is designed to handle session management. It requires an environment configuration and a session key for initialization.

The `checkSessionKey` method sends a POST request to validate the session key. If the request is successful and returns a status of 200, it returns the response data. If the request fails or returns a different status, it logs an error and returns an empty string.

**StorableRepositoryApi.ts**

The text represents a code implementation of an API wrapper for managing "storables," which are objects that can be saved, removed, loaded, found, and retrieved as recent records.

The `IStorableRepostoryApiWrapper` interface extends the `IStorablePageRepostoryApiWrapper` and provides methods for saving, removing, and loading storable records, as well as finding specific records and retrieving recent records.

The `StorableRepostoryApi` class implements these functionalities by using the Axios library to perform HTTP requests to the specified API endpoints. Each method returns a Promise that resolves with the result of the operation.

**StudioApi.Types.ts**

This text defines interfaces for a Studio API. 

1. The IStudioBoxerRequest interface contains a single property, 'question', which is a string.
2. The IStudioBoxerResponseEnrichment interface includes several properties: 'id' (string), 'summary' (string), and optional properties 'title', 'url', and 'iconUrl'.

**SummariseApi.Types.ts**

The text defines the structure for making a summary request through the Summarise API, outlining that the request should contain a text field and optionally, a length in words.

It also defines the structure of the response from the summarise request, specifying that the response will include a summary string.

**SuppressSummariseFailApi.Types.ts**

The provided text outlines the structure and definitions for the data elements of the "SuppressSummariseFail" API. 

It includes the structure for a summarise request object, which takes a text input and optionally a desired length in words.

It defines an enumeration `ESuppressSummariseFail` with two possible values: "Yes" and "No".

It also describes the structure of a summarise response object, which indicates the validity of the summary.

**TestForSummariseFailApi.Types.ts**

This text defines the structures and elements used in the SuppressSummariseFail API for Braid Technologies Ltd. It includes an interface for summarise request objects that contain text to be summarized and an optional word length. Additionally, it features an enum that specifies the possible outcomes of a summarisation attempt, such as "SummaryFailed" or "SummarySucceeded." Finally, it defines an interface for the summarise response object indicating whether the summary is valid based on the summarisation result.

**ThemeApi.ts**

This code defines an interface named `IFindThemeRequest`. 

The interface has two properties: `text`, which is a string, and `length`, which is a number.

The `IFindThemeRequest` interface is meant to specify criteria for finding a theme.
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SessionApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import axios from 'axios';

import { Api } from './Api';
import { IEnvironment } from "./IEnvironment";


export class SessionApi extends Api {

   /**
    * Initializes a new instance of the class with the provided environment and session key.
    * 
    * @param environment_ The environment settings to be used.
    * @param sessionKey_ The session key for authentication.
    */
   public constructor(environment_: IEnvironment, sessionKey_: string) {
      super (environment_, sessionKey_);
   }  

   /**
    * Asynchronously checks the validity of a session key by sending a POST request to the session API endpoint.
    * 
    * @returns A Promise that resolves to a boolean value indicating the validity of the session key.
    */
   async checkSessionKey () : Promise<string> {

      let apiUrl = this.environment.checkSessionApi() + "?session=" + this.sessionKey.toString();
      var response: any;

      try {
         response = await axios.post(apiUrl, {
         });

         if (response.status === 200) {
            return response.data;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return "";
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return "";       
      }          
   }
   
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\StorableRepositoryApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
import axios from 'axios';

import { IStorable, IStorableMultiQuerySpec as IStorablesQuerySpec, IStorableQuerySpec} from "./IStorable";

/**
 * Represents a wrapper for interacting with a repository of storable objects.
 * Provides methods to save storable records.
 */
export interface IStorablePageRepostoryApiWrapper {
   
   save (record: IStorable) : Promise<boolean>;  
};

/**
 * Represents a wrapper for interacting with a repository of storable objects.
 * Provides methods to save, remove, and load storable records.
 */
export interface IStorableRepostoryApiWrapper extends IStorablePageRepostoryApiWrapper{
   
   remove (recordId: string) : Promise<boolean>;
   load (recordId: string) : Promise<IStorable | undefined>;
   find (functionalSearchKey: string) : Promise<IStorable | undefined>;  
   recent (querySpec: IStorablesQuerySpec, url: string) : Promise<Array<IStorable>>;
};

/**
 * Represents an API for Storables.
 * 
 * @param {EEnvironment} environment_ - The environment to use for saving Storables.
 * @param {string} sessionKey_ - The session key for authentication.
 * 
 * @method save - Saves a record to the Storables API.
 * @method remove - removes a record
 * @method recent - return a list of recent Storables
 */
export class StorableRepostoryApi {

   /**
    * Initializes a new instance of the class 
    */
   public constructor() {
   }  

   /**
    * Asynchronously saves a record to the Storables repository API.
    * 
    * @param record - The record to be saved, must implement the IStorable interface.
    * @param url - fully factored URL to the API to call
    * @returns A Promise that resolves when the record is successfully saved, or rejects with an error.
    */
   async save (record: IStorable, url: string) : Promise<boolean> {

      var response: any;

      try {
         response = await axios.post(url, {request: record});

         if (response && response.status === 200) {
            return true;
         }
         else {
            console.error ("Error, status: " + response?.status);               
            return false;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return false;       
      }          
   }

   /**
    * Asynchronously removes a record from the Storables repository API.
    * 
    * @param recordId - The ID of the record to be removed.
    * @param url - fully factored URL to the API to call
    * @returns A Promise that resolves to true if the record is successfully removed, false otherwise.
    */
   async remove (recordId: string, url: string) : Promise<boolean> {

      let query: IStorableQuerySpec = {
         id: recordId,
         functionalSearchKey: undefined         
      }
      
      var response: any;

      try {
         response = await axios.post(url, {request: query});

         if (response && response.status === 200) {
            return true;
         }
         else {
            console.error ("Error, status: " + response?.status);               
            return false;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return false;       
      }          
   }

   /**
    * Asynchronously loads a record from the Storable repository API.
    * 
    * @param recordId - The ID of the record to be removed.
    * @param url - fully factored URL to the API to call
    * @returns A Promise that resolves to the record if successfully removed, undefined otherwise.
    */
   async load (recordId: string, url: string) : Promise<IStorable | undefined> {

      let query: IStorableQuerySpec = {
         id: recordId,
         functionalSearchKey: undefined
      }
      var response: any;

      try {
         response = await axios.post(url, {request: query});

         if (response && response.status === 200) {       
            return (response.data as IStorable);
         }
         else {
            console.error ("Error, status: " + response?.status);               
            return undefined;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return undefined;       
      } 
   }

   /**
    * Asynchronously finds a record from the Storable repository API.
    * 
    * @param recordId - The ID of the record to be removed.
    * @param url - fully factored URL to the API to call
    * @returns A Promise that resolves to the record if successfully removed, undefined otherwise.
    */
   async find (functionalSearchKey: string, url: string) : Promise<IStorable | undefined> {

      let query: IStorableQuerySpec = {
         id: undefined,
         functionalSearchKey: functionalSearchKey
      }
      var response: any;

      try {
         response = await axios.post(url, {request: query});

         if (response.status === 200) {          
            return (response.data as IStorable);
         }
         else {
            console.error ("Error, status: " + response.status);               
            return undefined;
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return undefined;       
      } 
   }

   /**
    * Asynchronously retrieves recent records from the Storables repository API based on the provided query specifications.
    * 
    * @param querySpec - The query specifications including the limit and storeClassName to filter the records.
    * @param url - fully factored URL to the API to call
    * @returns A Promise that resolves to an array of IStorable objects representing the recent records, or an empty array if an error occurs.
    */
   async recent (querySpec: IStorablesQuerySpec, url: string) : Promise<Array<IStorable>> {

      var response: any;

      try {
         response = await axios.post(url, {request: querySpec});

         if (response.status === 200) {

            let responseRecords = response.data;
            let storedRecords = new Array<IStorable>()

            for (let i = 0; i < responseRecords.length; i++) {
               storedRecords.push (responseRecords[i]);
            }

            return storedRecords;
         }
         else {
            console.error ("Error, status: " + response.status);               
            return new Array<IStorable>();
         }
      } catch (e: any) {       

         console.error ("Error: " + e?.response?.data);   
         return new Array<IStorable>();       
      }          
   }   
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\StudioApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the Studio API

/**
 * Interface for the StudioBoxer request object.
 */
export interface IStudioBoxerRequest {

   question: string;
}

/**
 * Interface for the IStudioBoxerResponseEnrichment response object.
 */
export interface IStudioBoxerResponseEnrichment {

   id: string,
   summary: string;    
   title: string | undefined;
   url: string | undefined;  
   iconUrl: string | undefined;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\StudioApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from StudioApi.Types.yaml with typeconv
  version: '1'
  x-id: StudioApi.Types.yaml
  x-comment: >-
    Generated from src\StudioApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    IStudioBoxerRequest:
      properties:
        question:
          title: IStudioBoxerRequest.question
          type: string
      required:
        - question
      additionalProperties: false
      title: IStudioBoxerRequest
      description: Interface for the StudioBoxer request object.
      type: object
    IStudioBoxerResponseEnrichment:
      properties:
        id:
          title: IStudioBoxerResponseEnrichment.id
          type: string
        summary:
          title: IStudioBoxerResponseEnrichment.summary
          type: string
        title:
          title: IStudioBoxerResponseEnrichment.title
          type: string
        url:
          title: IStudioBoxerResponseEnrichment.url
          type: string
        iconUrl:
          title: IStudioBoxerResponseEnrichment.iconUrl
          type: string
      required:
        - id
        - summary
        - title
        - url
        - iconUrl
      additionalProperties: false
      title: IStudioBoxerResponseEnrichment
      description: Interface for the IStudioBoxerResponseEnrichment response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SummariseApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the Summarise API

/**
 * Defines the structure of a summarise request object.
 */
export interface ISummariseRequest{

   text: string;
   lengthInWords?: number | undefined;
}

/**
 * Defines the structure of a summarise response object.
 */
export interface ISummariseResponse {

   summary: string;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SummariseApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from SummariseApi.Types.yaml with typeconv
  version: '1'
  x-id: SummariseApi.Types.yaml
  x-comment: >-
    Generated from src\SummariseApi.Types.ts by core-types-json-schema
    (https://github.com/grantila/core-types-json-schema) on behalf of typeconv
    (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    ISummariseRequest:
      properties:
        text:
          title: ISummariseRequest.text
          type: string
        lengthInWords:
          title: ISummariseRequest.lengthInWords
          type: number
      required:
        - text
      additionalProperties: false
      title: ISummariseRequest
      description: Defines the structure of a summarise request object.
      type: object
    ISummariseResponse:
      properties:
        summary:
          title: ISummariseResponse.summary
          type: string
      required:
        - summary
      additionalProperties: false
      title: ISummariseResponse
      description: Defines the structure of a summarise response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SuppressSummariseFailApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the SuppressSummariseFail API

/**
 * Defines the structure of a summarise request object.
 */
export interface ISuppressSummariseFailRequest{

   text: string;
   lengthInWords?: number | undefined;
}

export enum ESuppressSummariseFail {
   kYes = "Yes",
   kNo = "No"
}

/**
 * Defines the structure of a summarise response object.
 */
export interface ISuppressSummariseFailResponse {

   isValidSummary: ESuppressSummariseFail;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\SuppressSummariseFailApi.Types.yaml
****************************************
openapi: 3.0.0
info:
  title: Converted from SuppressSummariseFailApi.Types.yaml with typeconv
  version: '1'
  x-id: SuppressSummariseFailApi.Types.yaml
  x-comment: >-
    Generated from src\SuppressSummariseFailApi.Types.ts by
    core-types-json-schema (https://github.com/grantila/core-types-json-schema)
    on behalf of typeconv (https://github.com/grantila/typeconv)
paths: {}
components:
  schemas:
    ISuppressSummariseFailRequest:
      properties:
        text:
          title: ISuppressSummariseFailRequest.text
          type: string
        lengthInWords:
          title: ISuppressSummariseFailRequest.lengthInWords
          type: number
      required:
        - text
      additionalProperties: false
      title: ISuppressSummariseFailRequest
      description: Defines the structure of a summarise request object.
      type: object
    ISuppressSummariseFailResponse:
      properties:
        isValidSummary:
          title: ISuppressSummariseFailResponse.isValidSummary
      required:
        - isValidSummary
      additionalProperties: false
      title: ISuppressSummariseFailResponse
      description: Defines the structure of a summarise response object.
      type: object
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\TestForSummariseFailApi.Types.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the SuppressSummariseFail API

/**
 * Defines the structure of a summarise request object.
 */
export interface ITestForSummariseFailRequest{

   text: string;
   lengthInWords?: number | undefined;
}

export enum ETestForSummariseFail {
   kSummaryFailed = "SummaryFailed",
   kSummarySucceeded = "SummarySucceeded"
}

/**
 * Defines the structure of a summarise response object.
 */
export interface ITestForSummariseFailResponse {

   isValidSummary: ETestForSummariseFail;
}
****************************************

****************************************
WaterfallBrowser\src\CommonTs\src\ThemeApi.ts
****************************************
// Copyright (c) 2024 Braid Technologies Ltd
// Definitions for the data elements of the FindTheme API

/**
 * Interface for specifying the criteria to find a theme.
 * @interface
 */
export interface IFindThemeRequest{

   text: string;
   length : number;
}
****************************************
